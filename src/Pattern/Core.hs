-- | Core Pattern data type and basic operations.
--
-- This module defines the fundamental Pattern type as a recursive structure
-- that can represent graph elements and sequences.
--
-- == Conceptual Model: Patterns as Decorated Sequences
--
-- Conceptually, a Pattern is a decorated sequence: the elements form the pattern
-- itself, and the value provides decoration about that pattern.
-- For example, the pattern "A B B A" with decoration "Enclosed rhyme" represents
-- a specific sequence pattern (A B B A) that is classified as an "Enclosed rhyme".
-- The Pattern type represents such decorated sequences where:
--
-- * @elements@ - The pattern itself, represented as a sequence of elements
-- * @value@ - Decoration about what kind of pattern it is
--
-- The elements ARE the pattern; they are not subordinate to the value.
-- While implemented using a recursive tree structure, the primary semantic is that
-- elements form the pattern sequence itself. Each element in the sequence is itself
-- a Pattern, enabling arbitrarily nested and complex pattern structures.
--
-- == Implementation: Recursive Tree Structure
--
-- The Pattern type is implemented as a recursive tree structure, but this is purely
-- an implementation detail. The relationship between the sequence conceptual model
-- and tree implementation is:
--
-- **Primary Semantic (Conceptual)**: Patterns are decorated sequences where elements
-- form the pattern itself. The sequence order is essential to the pattern.
--
-- **Implementation Detail**: The tree structure is how sequences are represented in
-- memory. Each tree node stores a decoration (value) and contains the pattern elements
-- as a list, enabling recursive nesting.
--
-- **Relationship**: The tree implementation supports sequence semantics:
--
-- * The @elements@ field IS the pattern - it contains the sequence that defines the pattern
-- * The @value@ field provides decoration about what kind of pattern it is
-- * Tree traversal provides access to sequence elements in order
-- * The recursive structure enables patterns to contain patterns containing patterns, etc.
--
-- Conceptually, developers should think of patterns as decorated sequences where elements
-- form the pattern itself. The tree structure is an implementation detail that supports
-- sequence operations (ordering, length, access by position).
--
-- This recursive implementation enables:
--
-- * Atomic patterns: Patterns with no elements (@elements == []@), representing empty sequences. Atomic patterns are the fundamental building blocks from which all other patterns are constructed.
-- * Patterns with elements: Patterns containing one or more pattern elements in sequence
-- * Arbitrary nesting: Patterns can contain patterns containing patterns, enabling
--   deeply nested pattern structures
--
-- == Values and Pattern Decoration
--
-- Each Pattern instance decorates a sequence of elements with a value:
--
-- * The @value@ field stores decoration about what kind of pattern it is. This can be any type @v@,
--   such as a string identifier, an integer, a custom data type, etc.
-- * The @value@ is decoration about the pattern sequence itself, not part of the pattern.
-- * All patterns in a structure must share the same value type @v@ (enforced by the type system).
--
-- For example, an atomic pattern might have @value = "Person"@
-- (decoration indicating the pattern type) and @elements = []@ (empty sequence pattern).
-- A pattern with two elements might have @value = "knows"@ (the pattern type decoration)
-- and @elements = [atomA, atomB]@ (the pattern itself - a sequence of two atomic patterns).
--
-- == Elements and Pattern Structure
--
-- The @elements@ field IS the pattern - it contains the sequence that defines the pattern:
--
-- * An empty sequence (@elements == []@) represents a pattern with no elements (empty sequence)
-- * A non-empty sequence represents a pattern containing one or more pattern elements
-- * The elements are ordered and maintain their sequence order - this order is essential to the pattern
-- * Each element in the sequence is itself a Pattern, enabling recursive nesting
--
-- The pattern structure enables compositional patterns:
--
-- * A pattern can include other patterns as its elements
-- * Those element patterns can themselves include patterns
-- * This enables arbitrary depth nesting while maintaining the pattern sequence semantic
--
-- For example, a pattern might have @elements = [atom1, atom2, pair1]@
-- where each element is a Pattern. A pair pattern itself might have
-- @elements = [atomA, atomB]@, creating a nested pattern structure.
--
-- == Type Safety and Type Parameter @v@
--
-- The Pattern type is parameterized over value type @v@:
--
-- * @Pattern v@ allows patterns to store values of any type @v@
-- * All patterns in a structure must share the same value type @v@
-- * This type consistency is enforced by Haskell's type system
-- * The type parameter ensures type safety when working with patterns
--
-- For example:
--
-- * @Pattern String@ - patterns storing string values
-- * @Pattern Int@ - patterns storing integer values
-- * @Pattern Person@ - patterns storing custom Person values
--
-- Type consistency means that if you have a @Pattern String@, all patterns in
-- its @elements@ list must also be @Pattern String@. This prevents mixing
-- different value types within a single pattern structure.
--
-- == Mathematical Foundation
--
-- Patterns form the foundation for category-theoretic graph representations.
-- The recursive structure enables functor instances and supports various graph
-- interpretations through categorical views. The sequence semantic aligns with
-- categorical composition and transformation operations.
--
-- The Pattern type has a Functor instance that enables value transformation while
-- preserving pattern structure. This supports functional transformations and type
-- conversions essential for pattern manipulation. See the Functor instance documentation
-- below for details on structure preservation and functor laws.
--
-- The Pattern type has a Foldable instance that enables value aggregation over pattern
-- structures. This supports operations like summing values, concatenating strings, counting
-- elements, and computing statistics without manually traversing the pattern tree. The instance
-- provides @foldr@ for right-associative folding, @foldl@ for left-associative folding, and
-- @toList@ for extracting all values as a flat list. See the Foldable instance documentation
-- below for details on value aggregation and folding operations.
--
-- == Examples
--
-- Atomic pattern:
--
-- >>> atom = Pattern { value = "atom1", elements = [] }
-- >>> value atom
-- "atom1"
-- >>> elements atom
-- []
--
-- Pattern with elements:
--
-- >>> elem1 = Pattern { value = "elem1", elements = [] }
-- >>> elem2 = Pattern { value = "elem2", elements = [] }
-- >>> pattern = Pattern { value = "pattern", elements = [elem1, elem2] }
-- >>> value pattern
-- "pattern"
-- >>> length (elements pattern)
-- 2
-- >>> map value (elements pattern)
-- ["elem1","elem2"]
--
-- Nested patterns (arbitrary depth):
--
-- >>> level3 = Pattern { value = "level3", elements = [] }
-- >>> level2 = Pattern { value = "level2", elements = [level3] }
-- >>> level1 = Pattern { value = "level1", elements = [level2] }
-- >>> nested = Pattern { value = "root", elements = [level1] }
-- >>> value nested
-- "root"
-- >>> value (head (elements nested))
-- "level1"
--
-- Atomic patterns with different value types:
--
-- >>> leafString = Pattern { value = "text", elements = [] }
-- >>> leafInt = Pattern { value = 42, elements = [] }
-- >>> value leafString
-- "text"
-- >>> value leafInt
-- 42
--
-- Patterns with varying numbers of elements:
--
-- >>> zeroElements = Pattern { value = "zero", elements = [] }
-- >>> oneElement = Pattern { value = "one", elements = [Pattern { value = "elem", elements = [] }] }
-- >>> manyElements = Pattern { value = "many", elements = [Pattern { value = "e1", elements = [] }, Pattern { value = "e2", elements = [] }] }
-- >>> length (elements zeroElements)
-- 0
-- >>> length (elements oneElement)
-- 1
-- >>> length (elements manyElements)
-- 2
module Pattern.Core where

-- | A recursive structure representing a decorated sequence pattern.
--
-- Conceptually, a Pattern is a decorated sequence: the elements form the pattern
-- itself, and the value provides decoration about that pattern.
-- For example, the pattern "A B B A" with decoration "Enclosed rhyme" represents
-- a specific sequence pattern (A B B A) that is classified as an "Enclosed rhyme".
-- The Pattern type represents such decorated sequences where each element is itself
-- a Pattern, enabling recursive nesting.
--
-- Patterns form the foundation for representing graph elements and sequences.
-- Each pattern decorates a sequence of pattern elements with a value of any type.
-- The recursive structure enables compositional and nested patterns while maintaining
-- the decorated sequence semantic.
--
-- The Pattern type is intentionally minimal - it provides just the structure
-- needed for recursive sequence representation. Classification functions
-- (identifying nodes, relationships, subgraphs) will be added in future phases.
--
-- === Type Parameter @v@
--
-- The @v@ type parameter allows patterns to store decorations of any type.
-- All patterns in a structure must share the same value type @v@. This type
-- consistency is enforced by Haskell's type system, ensuring type safety when
-- working with patterns.
--
-- For example, @Pattern String@ represents patterns with string decorations,
-- @Pattern Int@ represents patterns with integer decorations, and @Pattern Person@
-- represents patterns with custom Person decorations. All elements in a pattern's
-- sequence must have the same decoration type as the pattern itself.
--
-- === Pattern Structural Classifications
--
-- Patterns have structural classifications based on their element structure:
--
-- * Atomic pattern: @elements == []@ - a sequence with no elements. Atomic patterns are the fundamental building blocks from which all other patterns are constructed.
-- * Singular pattern: @length (elements p) == 1@ - a sequence with exactly one element
-- * Pattern with elements: @elements@ contains one or more pattern elements
-- * Nested pattern: patterns containing patterns containing patterns, enabling arbitrary nesting
--
-- === Graph Interpretations (Views)
--
-- Patterns can be **interpreted** as graph elements through different views.
-- These are interpretations/views of pattern structures, not pattern variants themselves:
--
-- * Atomic patterns can be interpreted as nodes through graph views
-- * Patterns with 2 elements can be interpreted as relationships through graph views
-- * Patterns with elements can be interpreted as subgraphs through graph views
--
-- **Note**: Patterns are a data structure for representing graphs (like an adjacency matrix
-- or adjacency list), optimized for expressiveness of layered, hierarchical graph structures
-- rather than performance optimization over a single, "flat" graph.
--
-- === Examples
--
-- Creating an atomic pattern:
--
-- >>> atom = Pattern { value = "A", elements = [] }
--
-- Creating a pattern with elements (can be interpreted as a relationship):
--
-- >>> elem1 = Pattern { value = "A", elements = [] }
-- >>> elem2 = Pattern { value = "B", elements = [] }
-- >>> pattern = Pattern { value = "knows", elements = [elem1, elem2] }
--
-- Creating a pattern with multiple elements (can be interpreted as a subgraph):
--
-- >>> graph = Pattern { value = "myGraph", elements = [elem1, elem2, pattern] }
--
data Pattern v = Pattern 
  { -- | The decoration (value) associated with this pattern.
    --
    -- The @value@ field stores decoration about what kind of pattern it is.
    -- This can be any type @v@, such as a string identifier, an integer, or a
    -- custom data type. The value is decoration about the pattern sequence itself,
    -- not part of the pattern. The elements form the pattern; the value describes it.
    --
    -- Type parameter @v@ allows for different decoration types. All patterns in a
    -- structure must share the same value type (enforced by the type system).
    --
    -- === Examples
    --
    -- >>> value (Pattern { value = "test", elements = [] })
    -- "test"
    --
    -- >>> value (Pattern { value = 42, elements = [] })
    -- 42
    --
    -- >>> value (Pattern { value = "group", elements = [Pattern { value = "atom", elements = [] }] })
    -- "group"
    value    :: v
    
    -- | The pattern itself, represented as a sequence of elements.
    --
    -- The @elements@ field IS the pattern - it contains the sequence that defines
    -- the pattern. An empty list @[]@ represents a pattern with no elements
    -- (empty sequence). A non-empty list represents a pattern containing one or
    -- more pattern elements in sequence.
    --
    -- The elements maintain their sequence order and are accessible in that order.
    -- This order is essential to the pattern. Each element in the sequence is itself
    -- a Pattern, enabling recursive nesting where patterns can contain patterns
    -- containing patterns, etc., enabling arbitrary nesting depth while maintaining
    -- the pattern sequence semantic.
    --
    -- === Examples
    --
    -- Pattern with no elements (empty sequence):
    --
    -- >>> elements (Pattern { value = "empty", elements = [] })
    -- []
    --
    -- Singular pattern (one element):
    --
    -- >>> elem = Pattern { value = "elem", elements = [] }
    -- >>> elements (Pattern { value = "pattern", elements = [elem] })
    -- [Pattern {value = "elem", elements = []}]
    --
    -- Pattern with multiple elements:
    --
    -- >>> elem1 = Pattern { value = "elem1", elements = [] }
    -- >>> elem2 = Pattern { value = "elem2", elements = [] }
    -- >>> elements (Pattern { value = "pattern", elements = [elem1, elem2] })
    -- [Pattern {value = "elem1", elements = []},Pattern {value = "elem2", elements = []}]
  , elements :: [Pattern v]
  }
  deriving (Eq)

-- | Show instance for Pattern.
--
-- Displays patterns in a readable format showing both the value and elements.
-- The output format is: @Pattern {value = <value>, elements = [<elements>]}@
--
-- This instance requires that the value type @v@ has a @Show@ instance.
--
-- === Examples
--
-- >>> show (Pattern { value = "test", elements = [] })
-- "Pattern {value = \"test\", elements = []}"
--
-- >>> show (Pattern { value = 42, elements = [] })
-- "Pattern {value = 42, elements = []}"
--
instance Show v => Show (Pattern v) where
  show (Pattern v els) = 
    "Pattern {value = " ++ show v ++ ", elements = " ++ show els ++ "}"

-- | Functor instance for Pattern.
--
-- Transforms values in patterns while preserving pattern structure (element count,
-- nesting depth, element order). The transformation function is applied recursively
-- to all values in the pattern structure, including values at all nesting levels.
--
-- The Functor instance enables value transformation without manual pattern reconstruction.
-- This is essential for pattern composition, type conversion, and functional transformations
-- that are fundamental to practical pattern manipulation.
--
-- === Structure Preservation
--
-- The Functor instance preserves pattern structure during transformation:
--
-- * Element count: The number of elements remains unchanged
-- * Nesting depth: The nesting structure is preserved
-- * Element order: The order of elements is maintained
--
-- Only the values are transformed; the pattern structure itself remains identical.
--
-- === Functor Laws
--
-- The Functor instance satisfies the standard functor laws, which are verified
-- through property-based testing in the test suite:
--
-- **Identity Law**: For all patterns @p :: Pattern v@,
--
-- @
-- fmap id p = id p
-- @
--
-- This law states that applying the identity function to a pattern produces
-- the exact same pattern. The identity function leaves all values unchanged,
-- so the pattern structure and values remain identical.
--
-- **Composition Law**: For all patterns @p :: Pattern a@ and functions
-- @f :: b -> c@ and @g :: a -> b@,
--
-- @
-- fmap (f . g) p = (fmap f . fmap g) p
-- @
--
-- This law states that applying a composition of two functions to a pattern
-- produces the same result as applying each function sequentially. This enables
-- safe composition of transformations and predictable behavior when chaining
-- multiple transformations.
--
-- Both laws hold for all pattern structures (atomic, with elements, nested)
-- and all value types, as verified by property-based tests.
--
-- === Examples
--
-- Transforming atomic pattern with string value:
--
-- >>> atom = Pattern { value = "test", elements = [] }
-- >>> fmap (map toUpper) atom
-- Pattern {value = "TEST", elements = []}
--
-- Transforming pattern with multiple elements:
--
-- >>> elem1 = Pattern { value = "hello", elements = [] }
-- >>> elem2 = Pattern { value = "world", elements = [] }
-- >>> pattern = Pattern { value = "greeting", elements = [elem1, elem2] }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "GREETING", elements = [Pattern {value = "HELLO", elements = []},Pattern {value = "WORLD", elements = []}]}
--
-- Transforming pattern with integer values:
--
-- >>> elem1 = Pattern { value = 5, elements = [] }
-- >>> elem2 = Pattern { value = 10, elements = [] }
-- >>> pattern = Pattern { value = 20, elements = [elem1, elem2] }
-- >>> fmap (* 2) pattern
-- Pattern {value = 40, elements = [Pattern {value = 10, elements = []},Pattern {value = 20, elements = []}]}
--
-- Transforming nested pattern structure (3 levels):
--
-- >>> inner = Pattern { value = "inner", elements = [] }
-- >>> middle = Pattern { value = "middle", elements = [inner] }
-- >>> outer = Pattern { value = "outer", elements = [middle] }
-- >>> pattern = Pattern { value = "root", elements = [outer] }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "ROOT", elements = [Pattern {value = "OUTER", elements = [Pattern {value = "MIDDLE", elements = [Pattern {value = "INNER", elements = []}]}]}]}
--
-- Transforming deeply nested pattern structure (4+ levels):
--
-- >>> level4 = Pattern { value = "level4", elements = [] }
-- >>> level3 = Pattern { value = "level3", elements = [level4] }
-- >>> level2 = Pattern { value = "level2", elements = [level3] }
-- >>> level1 = Pattern { value = "level1", elements = [level2] }
-- >>> pattern = Pattern { value = "root", elements = [level1] }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "ROOT", elements = [Pattern {value = "LEVEL1", elements = [Pattern {value = "LEVEL2", elements = [Pattern {value = "LEVEL3", elements = [Pattern {value = "LEVEL4", elements = []}]}]}]}]}
--
-- Transforming pattern with varying nesting depths in different branches:
--
-- >>> branch1 = Pattern { value = "b1", elements = [Pattern { value = "b1leaf", elements = [] }] }
-- >>> branch2 = Pattern { value = "b2", elements = [Pattern { value = "b2mid", elements = [Pattern { value = "b2leaf", elements = [] }] }] }
-- >>> branch3 = Pattern { value = "b3", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [branch1, branch2, branch3] }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "ROOT", elements = [Pattern {value = "B1", elements = [Pattern {value = "B1LEAF", elements = []}]},Pattern {value = "B2", elements = [Pattern {value = "B2MID", elements = [Pattern {value = "B2LEAF", elements = []}]}]},Pattern {value = "B3", elements = []}]}
--
-- Type transformation (String to Int):
--
-- >>> elem1 = Pattern { value = "5", elements = [] }
-- >>> elem2 = Pattern { value = "10", elements = [] }
-- >>> pattern = Pattern { value = "20", elements = [elem1, elem2] }
-- >>> fmap (read :: String -> Int) pattern
-- Pattern {value = 20, elements = [Pattern {value = 5, elements = []},Pattern {value = 10, elements = []}]}
--
-- === Edge Cases
--
-- The Functor instance handles all pattern structures correctly:
--
-- **Atomic patterns** (no elements):
--
-- >>> atom = Pattern { value = "atom", elements = [] }
-- >>> fmap (map toUpper) atom
-- Pattern {value = "ATOM", elements = []}
--
-- **Singular patterns** (one element):
--
-- >>> elem = Pattern { value = "elem", elements = [] }
-- >>> pattern = Pattern { value = "singular", elements = [elem] }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "SINGULAR", elements = [Pattern {value = "ELEM", elements = []}]}
--
-- **Pair patterns** (two elements):
--
-- >>> elem1 = Pattern { value = "first", elements = [] }
-- >>> elem2 = Pattern { value = "second", elements = [] }
-- >>> pattern = Pattern { value = "pair", elements = [elem1, elem2] }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "PAIR", elements = [Pattern {value = "FIRST", elements = []},Pattern {value = "SECOND", elements = []}]}
--
-- **Extended patterns** (many elements):
--
-- >>> elems = [Pattern { value = "a", elements = [] }, Pattern { value = "b", elements = [] }, Pattern { value = "c", elements = [] }]
-- >>> pattern = Pattern { value = "extended", elements = elems }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "EXTENDED", elements = [Pattern {value = "A", elements = []},Pattern {value = "B", elements = []},Pattern {value = "C", elements = []}]}
--
-- **Type transformations** (Int to String):
--
-- >>> elem1 = Pattern { value = 5, elements = [] }
-- >>> elem2 = Pattern { value = 10, elements = [] }
-- >>> pattern = Pattern { value = 20, elements = [elem1, elem2] }
-- >>> fmap show pattern
-- Pattern {value = "20", elements = [Pattern {value = "5", elements = []},Pattern {value = "10", elements = []}]}
--
instance Functor Pattern where
  fmap f (Pattern v els) = Pattern (f v) (map (fmap f) els)

-- | Foldable instance for Pattern.
--
-- Enables folding over all values in a pattern structure, including the pattern's
-- own value and all element values at all nesting levels. The Foldable instance
-- provides value aggregation capabilities, allowing developers to compute statistics,
-- combine values, and perform calculations over pattern structures without manually
-- traversing the pattern tree.
--
-- === Value Aggregation
--
-- The Foldable instance processes all values in the pattern structure:
--
-- * The pattern's own value is included in folding operations
-- * All element values are processed recursively
-- * Values from all nesting levels are included
--
-- This enables efficient aggregation operations like summing integers, concatenating
-- strings, counting elements, or computing custom statistics over pattern values.
--
-- === Folding Order
--
-- The @foldr@ operation processes values in right-to-left order:
--
-- * Element values are processed first (right-to-left through the elements list)
-- * The pattern's own value is processed last
--
-- This order ensures that when building data structures or applying operations that
-- depend on processing order, the pattern's own value is combined with the already
-- processed element values.
--
-- === Foldable Laws
--
-- The Foldable instance satisfies standard foldable laws and properties:
--
-- * All values in the pattern structure are processed exactly once
-- * Folding operations work correctly for all pattern structures (atomic, with elements, nested)
-- * The implementation follows standard Foldable semantics for recursive data structures
--
-- === Examples
--
-- Summing integer values from an atomic pattern:
--
-- >>> atom = Pattern { value = 5, elements = [] }
-- >>> foldr (+) 0 atom
-- 5
--
-- Summing integer values from a pattern with multiple elements:
--
-- >>> elem1 = Pattern { value = 10, elements = [] }
-- >>> elem2 = Pattern { value = 20, elements = [] }
-- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
-- >>> foldr (+) 0 pattern
-- 130
--
-- Concatenating string values from a pattern:
--
-- >>> elem1 = Pattern { value = "hello", elements = [] }
-- >>> elem2 = Pattern { value = "world", elements = [] }
-- >>> pattern = Pattern { value = "greeting", elements = [elem1, elem2] }
-- >>> foldr (++) "" pattern
-- "greetinghelloworld"
--
-- Summing values from a nested pattern structure:
--
-- >>> inner = Pattern { value = 1, elements = [] }
-- >>> middle = Pattern { value = 2, elements = [inner] }
-- >>> outer = Pattern { value = 3, elements = [middle] }
-- >>> pattern = Pattern { value = 4, elements = [outer] }
-- >>> foldr (+) 0 pattern
-- 10
--
-- Counting all values in a pattern:
--
-- >>> elem1 = Pattern { value = "a", elements = [] }
-- >>> elem2 = Pattern { value = "b", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [elem1, elem2] }
-- >>> foldr (\_ acc -> acc + 1) 0 pattern
-- 3
--
-- === Edge Cases
--
-- The Foldable instance handles all pattern structures correctly:
--
-- **Atomic patterns** (no elements):
--
-- >>> atom = Pattern { value = 42, elements = [] }
-- >>> foldr (+) 0 atom
-- 42
--
-- **Patterns with empty elements list**:
--
-- >>> pattern = Pattern { value = 10, elements = [] }
-- >>> foldr (+) 0 pattern
-- 10
--
-- **Singular patterns** (one element):
--
-- >>> elem = Pattern { value = 5, elements = [] }
-- >>> pattern = Pattern { value = 10, elements = [elem] }
-- >>> foldr (+) 0 pattern
-- 15
--
-- **Nested patterns** (multiple levels):
--
-- >>> level3 = Pattern { value = 1, elements = [] }
-- >>> level2 = Pattern { value = 2, elements = [level3] }
-- >>> level1 = Pattern { value = 3, elements = [level2] }
-- >>> pattern = Pattern { value = 4, elements = [level1] }
-- >>> foldr (+) 0 pattern
-- 10
--
instance Foldable Pattern where
  -- | Right-associative fold over pattern values.
  --
  -- Processes all values in the pattern structure, including the pattern's own value
  -- and all element values at all nesting levels. Element values are processed first
  -- (right-to-left through the elements list), then the pattern's own value is combined
  -- with the accumulated result.
  --
  -- === Processing Order
  --
  -- The @foldr@ operation processes values in a specific order:
  --
  -- 1. Element values are processed first (right-to-left through the elements list)
  -- 2. The pattern's own value is processed last (combined with accumulated elements)
  --
  -- When building lists with @foldr (:) []@ or using @toList@, this results in the
  -- pattern's own value appearing first in the list, followed by element values in order.
  --
  -- === Examples
  --
  -- Atomic pattern:
  --
  -- >>> atom = Pattern { value = 5, elements = [] }
  -- >>> foldr (+) 0 atom
  -- 5
  --
  -- Pattern with multiple elements (order: elements first, then pattern's value):
  --
  -- >>> elem1 = Pattern { value = 10, elements = [] }
  -- >>> elem2 = Pattern { value = 20, elements = [] }
  -- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
  -- >>> foldr (+) 0 pattern
  -- 130
  --
  -- Building a list preserves order (pattern's value first, then elements):
  --
  -- >>> toList pattern
  -- [100, 10, 20]
  --
  -- Nested pattern structure:
  --
  -- >>> inner = Pattern { value = 1, elements = [] }
  -- >>> middle = Pattern { value = 2, elements = [inner] }
  -- >>> pattern = Pattern { value = 3, elements = [middle] }
  -- >>> foldr (+) 0 pattern
  -- 6
  --
  -- Order preservation in nested structures:
  --
  -- >>> toList pattern
  -- [3, 2, 1]
  --
  -- === Right-Associativity
  --
  -- The @foldr@ operation is right-associative, meaning operations are grouped from
  -- right to left. For commutative operations like addition, this produces the same
  -- result as left-associative folding. For non-commutative operations, the order
  -- matters and is preserved as described above.
  --
  -- Example with commutative operation (addition):
  --
  -- >>> elem1 = Pattern { value = 10, elements = [] }
  -- >>> elem2 = Pattern { value = 20, elements = [] }
  -- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
  -- >>> foldr (+) 0 pattern
  -- 130
  -- >>> foldr (+) 0 (toList pattern)
  -- 130
  --
  -- Example with non-commutative operation (list building):
  --
  -- >>> elem1 = Pattern { value = "a", elements = [] }
  -- >>> elem2 = Pattern { value = "b", elements = [] }
  -- >>> pattern = Pattern { value = "root", elements = [elem1, elem2] }
  -- >>> toList pattern
  -- ["root", "a", "b"]
  --
  foldr f z (Pattern v els) = f v (foldr (\e acc -> foldr f acc e) z els)
  
  -- | Left-associative fold over pattern values.
  --
  -- Processes all values in the pattern structure, including the pattern's own value
  -- and all element values at all nesting levels. Values are processed in left-to-right
  -- order: the pattern's own value is processed first, then element values are processed
  -- recursively from left to right.
  --
  -- === Processing Order
  --
  -- The @foldl@ operation processes values in a specific order:
  --
  -- 1. The pattern's own value is processed first (combined with initial accumulator)
  -- 2. Element values are processed recursively from left to right
  --
  -- This order ensures that when applying operations that require strict left-to-right
  -- evaluation, the pattern's own value is combined first, followed by element values
  -- in their natural order.
  --
  -- === Examples
  --
  -- Atomic pattern:
  --
  -- >>> atom = Pattern { value = 5, elements = [] }
  -- >>> foldl (+) 0 atom
  -- 5
  --
  -- Pattern with multiple elements (order: pattern's value first, then elements left-to-right):
  --
  -- >>> elem1 = Pattern { value = 10, elements = [] }
  -- >>> elem2 = Pattern { value = 20, elements = [] }
  -- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
  -- >>> foldl (+) 0 pattern
  -- 130
  --
  -- Computing running total with left-associative operations:
  --
  -- >>> foldl (-) 0 pattern
  -- -130
  --
  -- Nested pattern structure:
  --
  -- >>> inner = Pattern { value = 1, elements = [] }
  -- >>> middle = Pattern { value = 2, elements = [inner] }
  -- >>> pattern = Pattern { value = 3, elements = [middle] }
  -- >>> foldl (+) 0 pattern
  -- 6
  --
  -- === Left-Associativity
  --
  -- The @foldl@ operation is left-associative, meaning operations are grouped from
  -- left to right. For commutative operations like addition, this produces the same
  -- result as right-associative folding. For non-commutative operations, the order
  -- matters and is preserved as described above.
  --
  -- Example with commutative operation (addition):
  --
  -- >>> elem1 = Pattern { value = 10, elements = [] }
  -- >>> elem2 = Pattern { value = 20, elements = [] }
  -- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
  -- >>> foldl (+) 0 pattern
  -- 130
  -- >>> foldl (+) 0 (toList pattern)
  -- 130
  --
  -- Example with non-commutative operation (subtraction):
  --
  -- >>> elem1 = Pattern { value = 5, elements = [] }
  -- >>> elem2 = Pattern { value = 3, elements = [] }
  -- >>> pattern = Pattern { value = 10, elements = [elem1, elem2] }
  -- >>> foldl (-) 0 pattern
  -- -18
  --
  foldl f z (Pattern v els) = Prelude.foldl (\acc e -> foldl f acc e) (f z v) els
  
  -- Note: @toList@ is automatically derived from @foldr@ and extracts all values
  -- as a flat list. The pattern's own value and all element values at all
  -- nesting levels are included in the result.

-- | Create an atomic pattern (pattern with no elements) from a value.
--
-- This function provides a convenient way to create atomic patterns without
-- using verbose record syntax. The resulting pattern is functionally identical
-- to one created with @Pattern { value = x, elements = [] }@.
--
-- === Examples
--
-- Create an atomic pattern with a string value:
--
-- >>> atom = pattern "atom1"
-- >>> value atom
-- "atom1"
-- >>> elements atom
-- []
--
-- Create an atomic pattern with an integer value:
--
-- >>> num = pattern 42
-- >>> value num
-- 42
--
-- Create an atomic pattern with a custom type:
--
-- >>> data Person = Person { name :: String, age :: Maybe Int }
-- >>> person = pattern (Person "Alice" (Just 30))
-- >>> value person
-- Person {name = "Alice", age = Just 30}
--
-- === Functional Equivalence
--
-- The following are equivalent:
--
-- >>> pattern "test" == Pattern { value = "test", elements = [] }
-- True
pattern :: v -> Pattern v
pattern v = Pattern { value = v, elements = [] }

-- | Create a pattern with elements from a value and a list of pattern elements.
--
-- This function provides a convenient way to create patterns with elements
-- without using verbose record syntax. The resulting pattern is functionally
-- identical to one created with @Pattern { value = x, elements = ps }@.
--
-- The function preserves the order of elements in the input list and handles
-- all element counts: 0 (atomic pattern), 1 (singular pattern), 2 (pair),
-- or many (extended pattern).
--
-- === Examples
--
-- Create a singular pattern (one element):
--
-- >>> singular = patternWith "soccer" [pattern "a team sport involving kicking a ball"]
-- >>> length (elements singular)
-- 1
--
-- Create a pair pattern (two elements):
--
-- >>> pair = patternWith "knows" [pattern "Alice", pattern "Bob"]
-- >>> length (elements pair)
-- 2
--
-- Create an extended pattern (many elements):
--
-- >>> extended = patternWith "graph" [pattern "elem1", pattern "elem2", pattern "elem3"]
-- >>> length (elements extended)
-- 3
--
-- Empty list produces atomic pattern:
--
-- >>> atomic = patternWith "empty" []
-- >>> elements atomic
-- []
-- >>> atomic == pattern "empty"
-- True
--
-- === Functional Equivalence
--
-- The following are equivalent:
--
-- >>> patternWith "test" [pattern "elem"] == Pattern { value = "test", elements = [Pattern { value = "elem", elements = [] }] }
-- True
--
-- === Element Order
--
-- Element order is preserved:
--
-- >>> p1 = patternWith "seq" [pattern "a", pattern "b"]
-- >>> p2 = patternWith "seq" [pattern "b", pattern "a"]
-- >>> p1 == p2
-- False
patternWith :: v -> [Pattern v] -> Pattern v
patternWith v ps = Pattern { value = v, elements = ps }

-- | Create a pattern from a list of values by converting each value to an atomic pattern.
--
-- This function provides a convenient way to create patterns from lists of raw values.
-- Each value in the list is automatically converted to an atomic pattern, then all
-- atomic patterns are combined into a single pattern with the given decoration.
--
-- The function preserves the order of values in the input list and handles all
-- element counts: 0 (atomic pattern), 1 (singular pattern), 2 (pair), or many
-- (extended pattern).
--
-- === Examples
--
-- Create a pattern from a list of strings:
--
-- >>> p = fromList "graph" ["Alice", "Bob", "Charlie"]
-- >>> value p
-- "graph"
-- >>> length (elements p)
-- 3
-- >>> map value (elements p)
-- ["Alice","Bob","Charlie"]
--
-- Create a pattern from a list of integers:
--
-- >>> nums = fromList "numbers" [1, 2, 3, 4, 5]
-- >>> length (elements nums)
-- 5
--
-- Empty list produces atomic pattern:
--
-- >>> atomic = fromList "empty" []
-- >>> elements atomic
-- []
-- >>> atomic == pattern "empty"
-- True
--
-- === Functional Equivalence
--
-- The following are equivalent:
--
-- >>> fromList "test" ["a", "b"] == patternWith "test" [pattern "a", pattern "b"]
-- True
--
-- === Implementation
--
-- This function is implemented as:
--
-- @
-- fromList decoration values = patternWith decoration (map pattern values)
-- @
fromList :: v -> [v] -> Pattern v
fromList decoration values = patternWith decoration (map pattern values)

-- | Extract a pattern as a tuple preserving its structure.
--
-- Returns a tuple @(v, [Pattern v])@ where the first element is the pattern's
-- value and the second element is the list of element patterns. This function
-- preserves the pattern's structure by keeping elements as Pattern values
-- rather than flattening them.
--
-- The tuple representation directly reflects the Pattern's structure:
-- the value (decoration) and the list of pattern elements. This enables
-- structure-preserving operations and makes the pattern's composition explicit.
--
-- === Examples
--
-- Atomic pattern (no elements):
--
-- >>> atom = Pattern { value = "test", elements = [] }
-- >>> toTuple atom
-- ("test", [])
--
-- Pattern with multiple elements:
--
-- >>> elem1 = Pattern { value = "a", elements = [] }
-- >>> elem2 = Pattern { value = "b", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [elem1, elem2] }
-- >>> toTuple pattern
-- ("root", [Pattern {value = "a", elements = []},Pattern {value = "b", elements = []}])
--
-- Nested pattern structure:
--
-- >>> inner = Pattern { value = "inner", elements = [] }
-- >>> middle = Pattern { value = "middle", elements = [inner] }
-- >>> pattern = Pattern { value = "root", elements = [middle] }
-- >>> toTuple pattern
-- ("root", [Pattern {value = "middle", elements = [Pattern {value = "inner", elements = []}]}])
--
-- Pattern with integer values:
--
-- >>> elem1 = Pattern { value = 10, elements = [] }
-- >>> elem2 = Pattern { value = 20, elements = [] }
-- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
-- >>> toTuple pattern
-- (100, [Pattern {value = 10, elements = []},Pattern {value = 20, elements = []}])
--
-- === Structure Preservation
--
-- The @toTuple@ function preserves the pattern's structure:
--
-- * Elements remain as Pattern values (not flattened to their values)
-- * Nested structures are preserved in the elements list
-- * The pattern's value and elements are accessible separately
--
-- This is different from @toList@ which flattens all values into a single list.
-- Use @toTuple@ when you need to work with the pattern's value and elements
-- separately while maintaining the structural relationship.
--
-- === Edge Cases
--
-- **Atomic patterns** (no elements):
--
-- >>> atom = Pattern { value = "atom", elements = [] }
-- >>> toTuple atom
-- ("atom", [])
--
-- **Singular patterns** (one element):
--
-- >>> elem = Pattern { value = "elem", elements = [] }
-- >>> pattern = Pattern { value = "singular", elements = [elem] }
-- >>> toTuple pattern
-- ("singular", [Pattern {value = "elem", elements = []}])
--
-- **Patterns with many elements**:
--
-- >>> elems = [Pattern { value = "a", elements = [] }, Pattern { value = "b", elements = [] }, Pattern { value = "c", elements = [] }]
-- >>> pattern = Pattern { value = "root", elements = elems }
-- >>> toTuple pattern
-- ("root", [Pattern {value = "a", elements = []},Pattern {value = "b", elements = []},Pattern {value = "c", elements = []}])
--
toTuple :: Pattern v -> (v, [Pattern v])
toTuple (Pattern v els) = (v, els)
