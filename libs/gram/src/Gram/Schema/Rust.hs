{-# LANGUAGE OverloadedStrings #-}
-- | Module: Gram.Schema.Rust
--
-- Generates Rust type definitions for Pattern<Subject>.
--
-- This module provides functions to generate Rust structs and enums
-- that model Pattern<Subject> for downstream Rust ports.
--
-- @since 0.1.0
module Gram.Schema.Rust
  ( generateRustTypes
  ) where

import qualified Data.Text as T
import Data.Text (Text)

-- | Generate Rust type definitions for Pattern<Subject>
--
-- Returns Rust code with:
-- - Struct definitions for Pattern, Subject with serde derives
-- - Enum definition for Value types with #[serde(untagged)]
-- - Convenience constructors (new methods) for complex types
-- - Doc comments for documentation
--
-- Example usage:
-- @
-- let rustCode = generateRustTypes
-- writeFile "pattern.rs" (T.unpack rustCode)
-- @
--
-- @since 0.1.0
generateRustTypes :: Text
generateRustTypes = T.unlines
  [ "//! Pattern<Subject> Rust Type Definitions"
  , "//! Generated from gram-hs canonical JSON Schema"
  , "//! Version: 0.1.0"
  , ""
  , "use serde::{Deserialize, Serialize};"
  , "use std::collections::HashMap;"
  , ""
  , "/// A pattern with a subject value and optional nested pattern elements."
  , "///"
  , "/// Patterns are recursive: they can contain other patterns as elements."
  , "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
  , "pub struct Pattern {"
  , "    /// The subject value of this pattern"
  , "    pub value: Subject,"
  , "    /// Nested pattern elements"
  , "    pub elements: Vec<Pattern>,"
  , "}"
  , ""
  , "impl Pattern {"
  , "    /// Create a new Pattern with a subject and elements"
  , "    pub fn new(value: Subject, elements: Vec<Pattern>) -> Self {"
  , "        Self { value, elements }"
  , "    }"
  , ""
  , "    /// Create a new Pattern with a subject and no elements"
  , "    pub fn leaf(value: Subject) -> Self {"
  , "        Self { value, elements: Vec::new() }"
  , "    }"
  , "}"
  , ""
  , "/// A subject with identity (symbol), labels, and properties."
  , "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
  , "pub struct Subject {"
  , "    /// Identity symbol for the subject"
  , "    pub symbol: String,"
  , "    /// Set of labels classifying the subject"
  , "    pub labels: Vec<String>,"
  , "    /// Map of property names to values"
  , "    pub properties: HashMap<String, Value>,"
  , "}"
  , ""
  , "impl Subject {"
  , "    /// Create a new Subject with symbol, labels, and properties"
  , "    pub fn new(symbol: String, labels: Vec<String>, properties: HashMap<String, Value>) -> Self {"
  , "        Self { symbol, labels, properties }"
  , "    }"
  , ""
  , "    /// Create a new Subject with just a symbol (no labels or properties)"
  , "    pub fn simple(symbol: String) -> Self {"
  , "        Self {"
  , "            symbol,"
  , "            labels: Vec::new(),"
  , "            properties: HashMap::new(),"
  , "        }"
  , "    }"
  , "}"
  , ""
  , "/// Symbol value with type discriminator"
  , "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
  , "pub struct ValueSymbol {"
  , "    #[serde(rename = \"type\")]"
  , "    pub type_: String,"
  , "    pub value: String,"
  , "}"
  , ""
  , "impl ValueSymbol {"
  , "    /// Create a new ValueSymbol"
  , "    pub fn new(value: String) -> Self {"
  , "        Self {"
  , "            type_: \"symbol\".to_string(),"
  , "            value,"
  , "        }"
  , "    }"
  , "}"
  , ""
  , "/// Tagged string value (e.g., URL, JSON, code)"
  , "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
  , "pub struct ValueTaggedString {"
  , "    #[serde(rename = \"type\")]"
  , "    pub type_: String,"
  , "    pub tag: String,"
  , "    pub content: String,"
  , "}"
  , ""
  , "impl ValueTaggedString {"
  , "    /// Create a new ValueTaggedString"
  , "    pub fn new(tag: String, content: String) -> Self {"
  , "        Self {"
  , "            type_: \"tagged\".to_string(),"
  , "            tag,"
  , "            content,"
  , "        }"
  , "    }"
  , "}"
  , ""
  , "/// Numeric range value with optional bounds"
  , "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
  , "pub struct ValueRange {"
  , "    #[serde(rename = \"type\")]"
  , "    pub type_: String,"
  , "    pub lower: Option<f64>,"
  , "    pub upper: Option<f64>,"
  , "}"
  , ""
  , "impl ValueRange {"
  , "    /// Create a new ValueRange with both bounds"
  , "    pub fn new(lower: Option<f64>, upper: Option<f64>) -> Self {"
  , "        Self {"
  , "            type_: \"range\".to_string(),"
  , "            lower,"
  , "            upper,"
  , "        }"
  , "    }"
  , ""
  , "    /// Create a closed range (both bounds present)"
  , "    pub fn closed(lower: f64, upper: f64) -> Self {"
  , "        Self::new(Some(lower), Some(upper))"
  , "    }"
  , "}"
  , ""
  , "/// Measurement value with unit and numeric value"
  , "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
  , "pub struct ValueMeasurement {"
  , "    #[serde(rename = \"type\")]"
  , "    pub type_: String,"
  , "    pub unit: String,"
  , "    pub value: f64,"
  , "}"
  , ""
  , "impl ValueMeasurement {"
  , "    /// Create a new ValueMeasurement"
  , "    pub fn new(unit: String, value: f64) -> Self {"
  , "        Self {"
  , "            type_: \"measurement\".to_string(),"
  , "            unit,"
  , "            value,"
  , "        }"
  , "    }"
  , "}"
  , ""
  , "/// Value can be integer, number, boolean, string, symbol, tagged string,"
  , "/// array, map, range, or measurement."
  , "///"
  , "/// This uses serde's untagged enum for flexible JSON deserialization."
  , "/// Complex types use a 'type' field for discrimination."
  , "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
  , "#[serde(untagged)]"
  , "pub enum Value {"
  , "    /// Symbol value"
  , "    Symbol(ValueSymbol),"
  , "    /// Tagged string value"
  , "    TaggedString(ValueTaggedString),"
  , "    /// Range value"
  , "    Range(ValueRange),"
  , "    /// Measurement value"
  , "    Measurement(ValueMeasurement),"
  , "    /// Array of values"
  , "    Array(Vec<Value>),"
  , "    /// Map of string keys to values (plain object without 'type' field)"
  , "    Map(HashMap<String, Value>),"
  , "    /// Integer or floating-point number"
  , "    Number(f64),"
  , "    /// Boolean value"
  , "    Boolean(bool),"
  , "    /// String value"
  , "    String(String),"
  , "}"
  , ""
  , "impl Value {"
  , "    /// Check if this value is a symbol"
  , "    pub fn is_symbol(&self) -> bool {"
  , "        matches!(self, Value::Symbol(_))"
  , "    }"
  , ""
  , "    /// Check if this value is a tagged string"
  , "    pub fn is_tagged_string(&self) -> bool {"
  , "        matches!(self, Value::TaggedString(_))"
  , "    }"
  , ""
  , "    /// Check if this value is a range"
  , "    pub fn is_range(&self) -> bool {"
  , "        matches!(self, Value::Range(_))"
  , "    }"
  , ""
  , "    /// Check if this value is a measurement"
  , "    pub fn is_measurement(&self) -> bool {"
  , "        matches!(self, Value::Measurement(_))"
  , "    }"
  , ""
  , "    /// Check if this value is an array"
  , "    pub fn is_array(&self) -> bool {"
  , "        matches!(self, Value::Array(_))"
  , "    }"
  , ""
  , "    /// Check if this value is a map"
  , "    pub fn is_map(&self) -> bool {"
  , "        matches!(self, Value::Map(_))"
  , "    }"
  , "}"
  ]
