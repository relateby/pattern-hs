-- | Core Pattern data type and basic operations.
--
-- This module defines the fundamental Pattern type as a recursive structure
-- that can represent graph elements and sequences.
--
-- == Conceptual Model: Patterns as Decorated Sequences
--
-- Conceptually, a Pattern is a decorated sequence: the elements form the pattern
-- itself, and the value provides decoration about that pattern.
-- For example, the pattern "A B B A" with decoration "Enclosed rhyme" represents
-- a specific sequence pattern (A B B A) that is classified as an "Enclosed rhyme".
-- The Pattern type represents such decorated sequences where:
--
-- * @elements@ - The pattern itself, represented as a sequence of elements
-- * @value@ - Decoration about what kind of pattern it is
--
-- The elements ARE the pattern; they are not subordinate to the value.
-- While implemented using a recursive tree structure, the primary semantic is that
-- elements form the pattern sequence itself. Each element in the sequence is itself
-- a Pattern, enabling arbitrarily nested and complex pattern structures.
--
-- == Implementation: Recursive Tree Structure
--
-- The Pattern type is implemented as a recursive tree structure, but this is purely
-- an implementation detail. The relationship between the sequence conceptual model
-- and tree implementation is:
--
-- **Primary Semantic (Conceptual)**: Patterns are decorated sequences where elements
-- form the pattern itself. The sequence order is essential to the pattern.
--
-- **Implementation Detail**: The tree structure is how sequences are represented in
-- memory. Each tree node stores a decoration (value) and contains the pattern elements
-- as a list, enabling recursive nesting.
--
-- **Relationship**: The tree implementation supports sequence semantics:
--
-- * The @elements@ field IS the pattern - it contains the sequence that defines the pattern
-- * The @value@ field provides decoration about what kind of pattern it is
-- * Tree traversal provides access to sequence elements in order
-- * The recursive structure enables patterns to contain patterns containing patterns, etc.
--
-- Conceptually, developers should think of patterns as decorated sequences where elements
-- form the pattern itself. The tree structure is an implementation detail that supports
-- sequence operations (ordering, length, access by position).
--
-- This recursive implementation enables:
--
-- * Atomic patterns: Patterns with no elements (@elements == []@), representing empty sequences. Atomic patterns are the fundamental building blocks from which all other patterns are constructed.
-- * Patterns with elements: Patterns containing one or more pattern elements in sequence
-- * Arbitrary nesting: Patterns can contain patterns containing patterns, enabling
--   deeply nested pattern structures
--
-- == Values and Pattern Decoration
--
-- Each Pattern instance decorates a sequence of elements with a value:
--
-- * The @value@ field stores decoration about what kind of pattern it is. This can be any type @v@,
--   such as a string identifier, an integer, a custom data type, etc.
-- * The @value@ is decoration about the pattern sequence itself, not part of the pattern.
-- * All patterns in a structure must share the same value type @v@ (enforced by the type system).
--
-- For example, an atomic pattern might have @value = "Person"@
-- (decoration indicating the pattern type) and @elements = []@ (empty sequence pattern).
-- A pattern with two elements might have @value = "knows"@ (the pattern type decoration)
-- and @elements = [atomA, atomB]@ (the pattern itself - a sequence of two atomic patterns).
--
-- == Elements and Pattern Structure
--
-- The @elements@ field IS the pattern - it contains the sequence that defines the pattern:
--
-- * An empty sequence (@elements == []@) represents a pattern with no elements (empty sequence)
-- * A non-empty sequence represents a pattern containing one or more pattern elements
-- * The elements are ordered and maintain their sequence order - this order is essential to the pattern
-- * Each element in the sequence is itself a Pattern, enabling recursive nesting
--
-- The pattern structure enables compositional patterns:
--
-- * A pattern can include other patterns as its elements
-- * Those element patterns can themselves include patterns
-- * This enables arbitrary depth nesting while maintaining the pattern sequence semantic
--
-- For example, a pattern might have @elements = [atom1, atom2, pair1]@
-- where each element is a Pattern. A pair pattern itself might have
-- @elements = [atomA, atomB]@, creating a nested pattern structure.
--
-- == Type Safety and Type Parameter @v@
--
-- The Pattern type is parameterized over value type @v@:
--
-- * @Pattern v@ allows patterns to store values of any type @v@
-- * All patterns in a structure must share the same value type @v@
-- * This type consistency is enforced by Haskell's type system
-- * The type parameter ensures type safety when working with patterns
--
-- For example:
--
-- * @Pattern String@ - patterns storing string values
-- * @Pattern Int@ - patterns storing integer values
-- * @Pattern Person@ - patterns storing custom Person values
--
-- Type consistency means that if you have a @Pattern String@, all patterns in
-- its @elements@ list must also be @Pattern String@. This prevents mixing
-- different value types within a single pattern structure.
--
-- == Mathematical Foundation
--
-- Patterns form the foundation for category-theoretic graph representations.
-- The recursive structure enables functor instances and supports various graph
-- interpretations through categorical views. The sequence semantic aligns with
-- categorical composition and transformation operations.
--
-- The Pattern type has a Functor instance that enables value transformation while
-- preserving pattern structure. This supports functional transformations and type
-- conversions essential for pattern manipulation. See the Functor instance documentation
-- below for details on structure preservation and functor laws.
--
-- The Pattern type has a Foldable instance that enables value aggregation over pattern
-- structures. This supports operations like summing values, concatenating strings, counting
-- elements, and computing statistics without manually traversing the pattern tree. The instance
-- provides @foldr@ for right-associative folding, @foldl@ for left-associative folding,
-- @foldMap@ for monoid-based aggregation, and @toList@ for extracting all values as a flat list.
-- The module also provides @flatten@ as an explicit function for extracting all values as a flat
-- list, equivalent to @toList@. See the Foldable instance documentation below for details on
-- value aggregation and folding operations.
--
-- The Pattern type has a Traversable instance that enables effectful traversal over pattern
-- structures while preserving pattern structure. This supports operations like validation,
-- state threading, IO operations, and error handling over pattern values. The instance provides
-- @traverse@ for applying effectful functions to all values and @sequenceA@ for sequencing
-- applicative effects. See the Traversable instance documentation below for details on effectful
-- traversal and structure preservation.
--
-- The Pattern type has an Ord instance that provides lexicographic ordering for patterns based
-- on their structure. Patterns are ordered by comparing their value first, then their elements
-- recursively. This ordering is consistent with the Eq instance and enables patterns to be
-- used as keys in Data.Map and elements in Data.Set. The Ord instance requires that the value
-- type @v@ has an Ord instance. See the Ord instance documentation below for details on
-- ordering rules and consistency with equality.
--
-- The Pattern type has a Semigroup instance that enables combining patterns by concatenating
-- their elements and combining their values using the value type's Semigroup instance. This
-- enables incremental pattern construction using standard Haskell combinators like `<>`,
-- `sconcat`, and `stimes`. The instance preserves the decorated sequence model where elements
-- form the pattern and values provide decoration. The Semigroup instance requires that the
-- value type @v@ has a Semigroup instance. See the Semigroup instance documentation below
-- for details on combination semantics and associativity.
--
-- The Pattern type has a Monoid instance that extends the Semigroup instance by providing
-- an identity element (`mempty`). The identity pattern has `mempty` value (from value type's
-- Monoid) and empty elements list, enabling identity-based operations and standard Monoid
-- combinators (e.g., `mconcat`) while preserving the decorated sequence model. The Monoid
-- instance requires that the value type @v@ has a Monoid instance. See the Monoid instance
-- documentation below for details on identity semantics and laws.
--
-- The Pattern type has a Hashable instance that enables using patterns as keys in `HashMap`
-- and elements in `HashSet` for efficient hash-based lookups and deduplication. The instance
-- uses structure-preserving hashing based on value and elements recursively, ensuring that
-- equal patterns (according to `Eq`) produce the same hash value while providing good
-- distribution. The Hashable instance requires that the value type @v@ has a Hashable
-- instance. See the Hashable instance documentation below for details on hash semantics and
-- consistency with equality.
--
-- The Pattern type has a Comonad instance that enables context-aware computations where
-- functions have access to the full structural context (parent, siblings, depth, indices) around
-- each value, not just the value itself. This extends beyond Foldable (which only provides
-- values) to enable computations that consider structural context, depth, position, and
-- relationships between pattern elements. The instance provides @extract@ (extract decoration
-- value), @duplicate@ (create pattern of contexts), and @extend@ (context-aware transformation),
-- satisfying all Comonad laws (extract-extend, extend-extract, extend composition). See the
-- Comonad instance documentation below for details on context-aware computation and relationship
-- to zippers.
--
-- The Pattern type provides query functions for introspecting pattern structure:
--
-- * @length@ - Returns the number of direct elements in a pattern's sequence (O(1))
-- * @size@ - Returns the total number of nodes in a pattern structure, including all nested patterns (O(n))
-- * @depth@ - Returns the maximum nesting depth of a pattern structure (O(n))
-- * @values@ - Extracts all values from a pattern structure as a flat list (O(n))
-- * @value@ - Field accessor for accessing a pattern's decoration value (O(1))
-- * @anyValue@ - Checks if any value in a pattern satisfies a predicate (O(n))
-- * @allValues@ - Checks if all values in a pattern satisfy a predicate (O(n))
-- * @filterPatterns@ - Filters all subpatterns (including root) matching a pattern predicate (O(n))
-- * @findPattern@ - Finds the first subpattern (including root) matching a pattern predicate (O(n))
-- * @findAllPatterns@ - Finds all subpatterns (including root) matching a pattern predicate (O(n))
-- * @matches@ - Checks if two patterns match structurally (O(n))
-- * @contains@ - Checks if a pattern contains a subpattern (O(n))
--
-- These query functions enable pattern introspection, validation, and analysis operations.
-- See individual function documentation for details on usage and performance characteristics.
--
-- == Examples
--
-- Atomic pattern:
--
-- >>> atom = pattern "atom1"
-- >>> value atom
-- "atom1"
-- >>> elements atom
-- []
--
-- Pattern with elements:
--
-- >>> elem1 = pattern "elem1"
-- >>> elem2 = pattern "elem2"
-- >>> pattern = patternWith "pattern" [elem1, elem2]
-- >>> value pattern
-- "pattern"
-- >>> length (elements pattern)
-- 2
-- >>> map value (elements pattern)
-- ["elem1","elem2"]
--
-- Nested patterns (arbitrary depth):
--
-- >>> level3 = pattern "level3"
-- >>> level2 = patternWith "level2" [level3]
-- >>> level1 = patternWith "level1" [level2]
-- >>> nested = patternWith "root" [level1]
-- >>> value nested
-- "root"
-- >>> value (head (elements nested))
-- "level1"
--
-- Atomic patterns with different value types:
--
-- >>> leafString = pattern "text"
-- >>> leafInt = pattern 42
-- >>> value leafString
-- "text"
-- >>> value leafInt
-- 42
--
-- Patterns with varying numbers of elements:
--
-- >>> zeroElements = pattern "zero"
-- >>> oneElement = patternWith "one" [pattern "elem"]
-- >>> manyElements = patternWith "many" [pattern "e1", pattern "e2"]
-- >>> length (elements zeroElements)
-- 0
-- >>> length (elements oneElement)
-- 1
-- >>> length (elements manyElements)
-- 2
{-# LANGUAGE InstanceSigs #-}
module Pattern.Core
  ( -- * Pattern Type
    Pattern(..)
    -- * Construction Functions
  , pattern
  , patternWith
  , fromList
    -- * Query Functions
  , length
  , size
  , depth
  , values
    -- Note: 'value' is exported via Pattern(..) as a field accessor
    -- * Predicate Functions
  , anyValue
  , allValues
  , filterPatterns
  , findPattern
  , findAllPatterns
  , matches
  , contains
    -- * Helper Functions
  , flatten
  , toTuple
    -- * Comonad Helper Functions
  , depthAt
  , sizeAt
  , indicesAt
    -- * Typeclass Instances
    -- All typeclass instances are exported automatically via Pattern(..)
    -- Instances: Show, Ord, Semigroup, Monoid, Hashable, Functor, Applicative, Foldable, Traversable, Comonad
  ) where

import Prelude hiding (length)
import qualified Prelude as P
import Control.Comonad (Comonad(..))
import Data.Foldable (toList)
import Data.Hashable (Hashable(..))
import Data.Monoid (Monoid(..))
import Data.Traversable (Traversable(..))

-- | A recursive structure representing a decorated sequence pattern.
--
-- Conceptually, a Pattern is a decorated sequence: the elements form the pattern
-- itself, and the value provides decoration about that pattern.
-- For example, the pattern "A B B A" with decoration "Enclosed rhyme" represents
-- a specific sequence pattern (A B B A) that is classified as an "Enclosed rhyme".
-- The Pattern type represents such decorated sequences where each element is itself
-- a Pattern, enabling recursive nesting.
--
-- Patterns form the foundation for representing graph elements and sequences.
-- Each pattern decorates a sequence of pattern elements with a value of any type.
-- The recursive structure enables compositional and nested patterns while maintaining
-- the decorated sequence semantic.
--
-- The Pattern type is intentionally minimal - it provides just the structure
-- needed for recursive sequence representation. Classification functions
-- (identifying nodes, relationships, subgraphs) will be added in future phases.
--
-- === Type Parameter @v@
--
-- The @v@ type parameter allows patterns to store decorations of any type.
-- All patterns in a structure must share the same value type @v@. This type
-- consistency is enforced by Haskell's type system, ensuring type safety when
-- working with patterns.
--
-- For example, @Pattern String@ represents patterns with string decorations,
-- @Pattern Int@ represents patterns with integer decorations, and @Pattern Person@
-- represents patterns with custom Person decorations. All elements in a pattern's
-- sequence must have the same decoration type as the pattern itself.
--
-- === Pattern Structural Classifications
--
-- Patterns have structural classifications based on their element structure:
--
-- * Atomic pattern: @elements == []@ - a sequence with no elements. Atomic patterns are the fundamental building blocks from which all other patterns are constructed.
-- * Singular pattern: @length (elements p) == 1@ - a sequence with exactly one element
-- * Pattern with elements: @elements@ contains one or more pattern elements
-- * Nested pattern: patterns containing patterns containing patterns, enabling arbitrary nesting
--
-- === Graph Interpretations (Views)
--
-- Patterns can be **interpreted** as graph elements through different views.
-- These are interpretations/views of pattern structures, not pattern variants themselves:
--
-- * Atomic patterns can be interpreted as nodes through graph views
-- * Patterns with 2 elements can be interpreted as relationships through graph views
-- * Patterns with elements can be interpreted as subgraphs through graph views
--
-- **Note**: Patterns are a data structure for representing graphs (like an adjacency matrix
-- or adjacency list), optimized for expressiveness of layered, hierarchical graph structures
-- rather than performance optimization over a single, "flat" graph.
--
-- === Examples
--
-- Creating an atomic pattern:
--
-- >>> atom = pattern "A"
--
-- Creating a pattern with elements (can be interpreted as a relationship):
--
-- >>> elem1 = pattern "A"
-- >>> elem2 = pattern "B"
-- >>> pattern = patternWith "knows" [elem1, elem2]
--
-- Creating a pattern with multiple elements (can be interpreted as a subgraph):
--
-- >>> graph = patternWith "myGraph" [elem1, elem2, pattern]
--
data Pattern v = Pattern 
  { -- | The decoration (value) associated with this pattern.
    --
    -- The @value@ field stores decoration about what kind of pattern it is.
    -- This can be any type @v@, such as a string identifier, an integer, or a
    -- custom data type. The value is decoration about the pattern sequence itself,
    -- not part of the pattern. The elements form the pattern; the value describes it.
    --
    -- Type parameter @v@ allows for different decoration types. All patterns in a
    -- structure must share the same value type (enforced by the type system).
    --
    -- The @value@ field accessor provides direct access to a pattern's decoration
    -- value without any computation. This is the primary way to access pattern
    -- decoration values for querying, analysis, and transformation operations.
    --
    -- === Accessing Pattern Values
    --
    -- The @value@ field accessor works with patterns of any value type and at any
    -- nesting level. Each pattern in a nested structure has its own value that can
    -- be accessed independently.
    --
    -- === Examples
    --
    -- Atomic pattern with string value:
    --
    -- >>> value (pattern "test")
    -- "test"
    --
    -- Atomic pattern with integer value:
    --
    -- >>> value (pattern 42)
    -- 42
    --
    -- Pattern with elements (accesses root value):
    --
    -- >>> value (patternWith "group" [pattern "atom"])
    -- "group"
    --
    -- Accessing values at different nesting levels:
    --
    -- >>> inner = pattern "inner"
    -- >>> middle = patternWith "middle" [inner]
    -- >>> outer = patternWith "outer" [middle]
    -- >>> pattern = patternWith "root" [outer]
    -- >>> value pattern
    -- "root"
    -- >>> value outer
    -- "outer"
    -- >>> value middle
    -- "middle"
    -- >>> value inner
    -- "inner"
    --
    -- Pattern with custom type value:
    --
    -- >>> data Person = Person { name :: String, age :: Maybe Int } deriving (Show)
    -- >>> person = Person "Alice" (Just 30)
    -- >>> value (pattern person)
    -- Person {name = "Alice", age = Just 30}
    --
    -- === Relationship to values function
    --
    -- The @value@ field accessor returns a single value (the pattern's own value),
    -- while the @values@ function returns all values from the entire pattern structure:
    --
    -- @
    -- value p == head (values p)
    -- @
    --
    -- The @value@ field provides O(1) access to the pattern's decoration, while
    -- @values@ extracts all values recursively.
    --
    -- === Performance
    --
    -- The @value@ field accessor is a direct field access operation with O(1) time
    -- complexity. No computation is required - it simply returns the stored value.
    --
    -- === Type Safety
    --
    -- The @value@ field accessor works with patterns of any value type @v@:
    --
    -- >>> value (pattern "test" :: Pattern String)
    -- "test"
    -- >>> value (pattern 42 :: Pattern Int)
    -- 42
    --
    value    :: v
    
    -- | The pattern itself, represented as a sequence of elements.
    --
    -- The @elements@ field IS the pattern - it contains the sequence that defines
    -- the pattern. An empty list @[]@ represents a pattern with no elements
    -- (empty sequence). A non-empty list represents a pattern containing one or
    -- more pattern elements in sequence.
    --
    -- The elements maintain their sequence order and are accessible in that order.
    -- This order is essential to the pattern. Each element in the sequence is itself
    -- a Pattern, enabling recursive nesting where patterns can contain patterns
    -- containing patterns, etc., enabling arbitrary nesting depth while maintaining
    -- the pattern sequence semantic.
    --
    -- === Examples
    --
    -- Pattern with no elements (empty sequence):
    --
    -- >>> elements (pattern "empty")
    -- []
    --
    -- Singular pattern (one element):
    --
    -- >>> elem = pattern "elem"
    -- >>> elements (patternWith "pattern" [elem])
    -- [Pattern {value = "elem", elements = []}]
    --
    -- Pattern with multiple elements:
    --
    -- >>> elem1 = pattern "elem1"
    -- >>> elem2 = pattern "elem2"
    -- >>> elements (patternWith "pattern" [elem1, elem2])
    -- [Pattern {value = "elem1", elements = []},Pattern {value = "elem2", elements = []}]
  , elements :: [Pattern v]
  }
  deriving (Eq)

-- | Show instance for Pattern.
--
-- Displays patterns in a readable format showing both the value and elements.
-- The output format is: @Pattern {value = <value>, elements = [<elements>]}@
--
-- This instance requires that the value type @v@ has a @Show@ instance.
--
-- === Examples
--
-- >>> show (pattern "test")
-- "Pattern {value = \"test\", elements = []}"
--
-- >>> show (pattern 42)
-- "Pattern {value = 42, elements = []}"
--
instance Show v => Show (Pattern v) where
  show (Pattern v els) = 
    "Pattern {value = " ++ show v ++ ", elements = " ++ show els ++ "}"

-- | Ord instance for Pattern.
--
-- Provides lexicographic ordering for patterns based on their structure.
-- Patterns are ordered by comparing their value first, then their elements
-- recursively. This ordering is consistent with the `Eq` instance and enables
-- patterns to be used as keys in `Data.Map` and elements in `Data.Set`.
--
-- === Ordering Rules
--
-- The `Ord` instance uses lexicographic ordering:
--
-- 1. **Value comparison first**: If two patterns have different values,
--    ordering is determined by comparing the values using the `Ord` instance
--    for the value type.
--
-- 2. **Element comparison second**: If two patterns have the same value,
--    ordering is determined by comparing their elements lists lexicographically.
--    Elements are compared recursively using the same ordering rules.
--
-- 3. **Structure preservation**: Patterns with different structures are
--    distinguished even if they have the same flattened values. This ensures
--    that ordering respects the pattern's structure as represented by `toTuple`.
--
-- === Consistency with Eq
--
-- The `Ord` instance is consistent with the `Eq` instance:
--
-- * Patterns that are equal according to `Eq` compare as `EQ`
-- * Patterns that are not equal according to `Eq` compare as `LT` or `GT`
-- * Ordering uses the same comparison order as `Eq` (value first, then elements)
--
-- === Examples
--
-- Atomic patterns with different values:
--
-- >>> compare (pattern "a") (pattern "b")
-- LT
-- >>> compare (pattern "b") (pattern "a")
-- GT
--
-- Patterns with same value but different elements:
--
-- >>> p1 = patternWith "root" [pattern "a"]
-- >>> p2 = patternWith "root" [pattern "b"]
-- >>> compare p1 p2
-- LT
--
-- Patterns with same value and same elements:
--
-- >>> p1 = patternWith "root" [pattern "a", pattern "b"]
-- >>> p2 = patternWith "root" [pattern "a", pattern "b"]
-- >>> compare p1 p2
-- EQ
--
-- Nested patterns (recursive comparison):
--
-- >>> inner1 = pattern "inner1"
-- >>> inner2 = pattern "inner2"
-- >>> outer1 = patternWith "outer" [patternWith "middle" [inner1]]
-- >>> outer2 = patternWith "outer" [patternWith "middle" [inner2]]
-- >>> compare outer1 outer2
-- LT
--
-- Using comparison operators:
--
-- >>> (pattern "a") < (pattern "b")
-- True
-- >>> (pattern "a") <= (pattern "b")
-- True
-- >>> (pattern "b") > (pattern "a")
-- True
--
-- Using min and max:
--
-- >>> min (pattern "a") (pattern "b")
-- Pattern {value = "a", elements = []}
-- >>> max (pattern "a") (pattern "b")
-- Pattern {value = "b", elements = []}
--
-- === Type Constraint
--
-- The `Ord` instance requires that the value type `v` has an `Ord` instance:
--
-- @
-- instance Ord v => Ord (Pattern v)
-- @
--
-- This ensures that pattern values can be compared, which is necessary for
-- lexicographic ordering. Attempting to use `Ord` operations on patterns with
-- non-orderable value types will result in a compile-time error.
--
-- === Relationship to toTuple
--
-- The ordering semantics are based on `toTuple()` structure-preserving
-- representation. Comparing two patterns is equivalent to comparing their
-- tuple representations:
--
-- @
-- compare p1 p2 == compare (toTuple p1) (toTuple p2)
-- @
--
-- This ensures that ordering distinguishes patterns with different structures
-- even if they have the same flattened values.
--
instance Ord v => Ord (Pattern v) where
  compare (Pattern v1 els1) (Pattern v2 els2) =
    compare v1 v2 `mappend` compare els1 els2

-- | Semigroup instance for Pattern.
--
-- Enables combining patterns by concatenating their elements and combining their
-- values using the value type's Semigroup instance. This enables incremental pattern
-- construction using standard Haskell combinators like `<>`, `sconcat`, and `stimes`.
--
-- === Combination Semantics
--
-- The Semigroup instance combines patterns following the decorated sequence model:
--
-- * **Value combination**: Values are combined using the value type's Semigroup instance:
--   @value (p1 <> p2) = value p1 <> value p2@
--
-- * **Element concatenation**: Elements are concatenated in order, preserving sequence semantics:
--   @elements (p1 <> p2) = elements p1 ++ elements p2@
--
-- * **Structure preservation**: The decorated sequence model is preserved - elements form the
--   pattern, value is decoration. Combining patterns extends the pattern sequence while
--   combining decorations.
--
-- === Semigroup Laws
--
-- The Semigroup instance satisfies the associativity law, which is verified through
-- property-based testing in the test suite:
--
-- **Associativity Law**: For all patterns @p1@, @p2@, @p3 :: Pattern v@ where @Semigroup v@,
--
-- @
-- (p1 <> p2) <> p3 = p1 <> (p2 <> p3)
-- @
--
-- This law ensures that pattern combination is associative, enabling safe use of
-- standard Semigroup combinators like `sconcat` and `stimes`.
--
-- === Type Constraint
--
-- The Semigroup instance requires that the value type @v@ has a Semigroup instance:
--
-- @
-- instance Semigroup v => Semigroup (Pattern v)
-- @
--
-- This ensures that pattern values can be combined, which is necessary for pattern
-- combination. Attempting to use `<>` on patterns with non-semigroup value types will
-- result in a compile-time error.
--
-- === Examples
--
-- Combining atomic patterns with String values (concatenation):
--
-- >>> p1 = pattern "hello"
-- >>> p2 = pattern "world"
-- >>> p1 <> p2
-- Pattern {value = "helloworld", elements = []}
--
-- Combining patterns with elements:
--
-- >>> elem1 = pattern "a"
-- >>> elem2 = pattern "b"
-- >>> p1 = patternWith "prefix" [elem1, elem2]
-- >>> p2 = patternWith "suffix" [pattern "c"]
-- >>> p1 <> p2
-- Pattern {value = "prefixsuffix", elements = [Pattern {value = "a", elements = []},Pattern {value = "b", elements = []},Pattern {value = "c", elements = []}]}
--
-- Combining patterns with Sum Int values (addition):
--
-- >>> p1 = pattern (Sum 5)
-- >>> p2 = pattern (Sum 3)
-- >>> getSum (value (p1 <> p2))
-- 8
--
-- Combining patterns with Product Int values (multiplication):
--
-- >>> p1 = pattern (Product 5)
-- >>> p2 = pattern (Product 3)
-- >>> getProduct (value (p1 <> p2))
-- 15
--
-- Using standard Semigroup combinators:
--
-- >>> sconcat (pattern "a" :| [pattern "b", pattern "c"])
-- Pattern {value = "abc", elements = []}
--
-- >>> stimes 3 (patternWith "x" [pattern "y"])
-- Pattern {value = "xxx", elements = [Pattern {value = "y", elements = []},Pattern {value = "y", elements = []},Pattern {value = "y", elements = []}]}
--
-- Combining nested patterns:
--
-- >>> inner1 = pattern "inner1"
-- >>> inner2 = pattern "inner2"
-- >>> middle1 = patternWith "middle1" [inner1]
-- >>> middle2 = patternWith "middle2" [inner2]
-- >>> p1 = patternWith "root1" [middle1]
-- >>> p2 = patternWith "root2" [middle2]
-- >>> result = p1 <> p2
-- >>> value result
-- "root1root2"
-- >>> length (elements result)
-- 2
--
-- === Edge Cases
--
-- The Semigroup instance handles all pattern structures correctly:
--
-- **Atomic patterns** (no elements):
--
-- >>> pattern "a" <> pattern "b"
-- Pattern {value = "ab", elements = []}
--
-- **Patterns with different element counts**:
--
-- >>> patternWith "a" [pattern "e1"] <> patternWith "b" [pattern "e2", pattern "e3"]
-- Pattern {value = "ab", elements = [Pattern {value = "e1", elements = []},Pattern {value = "e2", elements = []},Pattern {value = "e3", elements = []}]}
--
-- **Patterns with different nesting depths**:
--
-- >>> patternWith "a" [pattern "leaf"] <> patternWith "b" [patternWith "middle" [pattern "inner"]]
-- Pattern {value = "ab", elements = [Pattern {value = "leaf", elements = []},Pattern {value = "middle", elements = [Pattern {value = "inner", elements = []}]}]}
--
-- **Deeply nested patterns**:
--
-- The instance correctly handles patterns with arbitrary nesting depth, preserving
-- the nested structure in the combined result.
--
-- === Performance
--
-- The Semigroup instance has O(n+m) time complexity where n and m are the number of
-- elements in the two patterns being combined. Value combination is O(1) for most
-- Semigroup instances, and element concatenation is O(n+m) for list concatenation.
--
-- === Relationship to Decorated Sequence Model
--
-- The Semigroup instance aligns with the decorated sequence conceptual model:
--
-- * **Elements form the pattern**: Concatenation extends the pattern sequence by
--   appending elements from the right pattern to elements from the left pattern
--
-- * **Value is decoration**: Value combination provides decoration about the combined
--   pattern, using the value type's Semigroup semantics
--
-- This ensures that pattern combination maintains the semantic that elements form
-- the pattern itself while values provide decoration about that pattern.
--
-- === Integration with Standard Semigroup Combinators
--
-- The Semigroup instance enables standard Semigroup combinators:
--
-- * `sconcat :: NonEmpty (Pattern v) -> Pattern v`: Combines a non-empty list of patterns
-- * `stimes :: Integral n => n -> Pattern v -> Pattern v`: Repeats a pattern n times
--
-- These combinators work correctly with Pattern types and follow standard Semigroup
-- semantics.
--
instance Semigroup v => Semigroup (Pattern v) where
  -- | Combine two patterns by combining their values and concatenating their elements.
  --
  -- The combination operation:
  --
  -- 1. Combines values using the value type's Semigroup instance: @v1 <> v2@
  -- 2. Concatenates elements in order: @els1 ++ els2@
  --
  -- This preserves the decorated sequence model where elements form the pattern
  -- and values provide decoration.
  --
  -- === Examples
  --
  -- Combining atomic patterns:
  --
  -- >>> pattern "a" <> pattern "b"
  -- Pattern {value = "ab", elements = []}
  --
  -- Combining patterns with elements:
  --
  -- >>> patternWith "a" [pattern "e1"] <> patternWith "b" [pattern "e2"]
  -- Pattern {value = "ab", elements = [Pattern {value = "e1", elements = []},Pattern {value = "e2", elements = []}]}
  --
  -- === Associativity
  --
  -- The operation is associative:
  --
  -- @
  -- (p1 <> p2) <> p3 = p1 <> (p2 <> p3)
  -- @
  --
  -- This is verified through property-based testing.
  --
  Pattern v1 els1 <> Pattern v2 els2 = Pattern (v1 <> v2) (els1 ++ els2)

-- | Monoid instance for Pattern.
--
-- Extends the Semigroup instance by providing an identity element (`mempty`).
-- The identity pattern has `mempty` value (from value type's Monoid) and empty
-- elements list, enabling identity-based operations and standard Monoid combinators
-- (e.g., `mconcat`) while preserving the decorated sequence model.
--
-- === Identity Semantics
--
-- The Monoid instance provides an identity pattern:
--
-- * **Identity pattern**: `mempty = pattern mempty` (equivalent to `Pattern { value = mempty, elements = [] }`)
--   where `mempty` on the right side is from the value type's Monoid instance
--
-- * **Left identity**: `mempty <> p = p` for all patterns `p`
--
-- * **Right identity**: `p <> mempty = p` for all patterns `p`
--
-- * **Consistency**: Uses same `<>` implementation as Semigroup instance
--
-- === Monoid Laws
--
-- The Monoid instance satisfies the standard monoid laws, which are verified
-- through property-based testing in the test suite:
--
-- **Left Identity Law**: For all patterns @p :: Pattern v@ where @Monoid v@,
--
-- @
-- mempty <> p = p
-- @
--
-- **Right Identity Law**: For all patterns @p :: Pattern v@ where @Monoid v@,
--
-- @
-- p <> mempty = p
-- @
--
-- Both laws hold for all pattern structures (atomic, with elements, nested)
-- and all value types, as verified by property-based tests.
--
-- === Type Constraint
--
-- The Monoid instance requires that the value type @v@ has a Monoid instance:
--
-- @
-- instance Monoid v => Monoid (Pattern v)
-- @
--
-- This ensures that pattern values can provide identity elements, which is
-- necessary for the identity pattern. Attempting to use `mempty` on patterns
-- with non-monoid value types will result in a compile-time error.
--
-- === Examples
--
-- Identity pattern with String values (empty string):
--
-- >>> mempty :: Pattern String
-- Pattern {value = "", elements = []}
--
-- Identity pattern with Sum Int values (Sum 0):
--
-- >>> mempty :: Pattern (Sum Int)
-- Pattern {value = Sum 0, elements = []}
--
-- Left identity law:
--
-- >>> mempty <> pattern "test"
-- Pattern {value = "test", elements = []}
--
-- Right identity law:
--
-- >>> pattern "test" <> mempty
-- Pattern {value = "test", elements = []}
--
-- Using mconcat to combine patterns:
--
-- >>> mconcat [pattern "a", pattern "b", pattern "c"]
-- Pattern {value = "abc", elements = []}
--
-- Using mconcat with empty list:
--
-- >>> mconcat [] :: Pattern String
-- Pattern {value = "", elements = []}
--
-- === Consistency with Semigroup
--
-- The Monoid instance is consistent with the Semigroup instance:
--
-- * The `<>` operation is inherited from Semigroup
-- * `p1 <> p2` produces the same result whether using Semigroup or Monoid instance
-- * The identity pattern naturally extends Semigroup semantics
--
-- === Relationship to Decorated Sequence Model
--
-- The Monoid instance aligns with the decorated sequence conceptual model:
--
-- * **Elements form the pattern**: Identity has empty elements (no pattern sequence)
-- * **Value is decoration**: Identity has `mempty` value (no decoration)
--
-- When combining with identity, the pattern sequence and decoration remain unchanged,
-- which is the expected behavior for an identity element.
--
-- === Standard Monoid Combinators
--
-- The Monoid instance enables standard Monoid combinators:
--
-- * `mconcat :: [Pattern v] -> Pattern v`: Combines a list of patterns (returns `mempty` for empty list)
-- * `mappend :: Pattern v -> Pattern v -> Pattern v`: Alias for `<>` (inherited from Semigroup)
--
-- These combinators work correctly with Pattern types and follow standard Monoid semantics.
--
instance Monoid v => Monoid (Pattern v) where
  -- | The identity element for pattern combination.
  --
  -- Returns a pattern with `mempty` value (from value type's Monoid) and empty
  -- elements list. This serves as the identity element for the `<>` operation,
  -- satisfying both left and right identity laws.
  --
  -- === Identity Laws
  --
  -- The identity pattern satisfies:
  --
  -- * **Left identity**: `mempty <> p = p` for all patterns `p`
  -- * **Right identity**: `p <> mempty = p` for all patterns `p`
  --
  -- === Examples
  --
  -- Identity pattern for String values:
  --
  -- >>> mempty :: Pattern String
  -- Pattern {value = "", elements = []}
  --
  -- Identity pattern for Sum Int values:
  --
  -- >>> mempty :: Pattern (Sum Int)
  -- Pattern {value = Sum 0, elements = []}
  --
  -- Using identity in combination:
  --
  -- >>> mempty <> pattern "test"
  -- Pattern {value = "test", elements = []}
  --
  -- >>> pattern "test" <> mempty
  -- Pattern {value = "test", elements = []}
  --
  mempty = pattern mempty
  -- Note: <> is inherited from Semigroup instance
  -- Implementation: mempty = Pattern { value = mempty, elements = [] }

-- | Hashable instance for Pattern.
--
-- Enables using patterns as keys in `HashMap` and elements in `HashSet` for
-- efficient hash-based lookups and deduplication. The instance provides O(1)
-- average-case performance compared to O(log n) for ordered containers.
--
-- === Hash Semantics
--
-- The `Hashable` instance uses structure-preserving hashing: patterns are hashed
-- based on their structure (value and elements recursively), ensuring that equal
-- patterns (according to `Eq`) produce the same hash value while providing good
-- distribution to minimize collisions.
--
-- **Structure-preserving**: Hash patterns based on their structure (value and elements),
-- not flattened values. This distinguishes patterns with different structures even
-- if they have the same flattened values.
--
-- **Consistent with Eq**: For all patterns `p1` and `p2`, if `p1 == p2`, then
-- `hash p1 == hash p2`. This is a fundamental requirement for `Hashable` instances
-- and enables correct behavior in hash-based containers.
--
-- **Recursive**: Nested patterns are hashed recursively, ensuring deep structures
-- contribute to the hash value correctly.
--
-- **Good distribution**: Patterns with different structures produce different hash
-- values in the majority of cases, minimizing collisions.
--
-- === Hash Consistency with Eq
--
-- The hash function is designed to be consistent with the `Eq` instance:
--
-- * `Eq` compares value first, then elements recursively
-- * `Hashable` hashes value first, then elements recursively
-- * This ensures equal patterns produce the same hash
--
-- === Examples
--
-- Hashing atomic patterns:
--
-- >>> hash (pattern "a" :: Pattern String)
-- <hash value>
--
-- >>> hash (pattern "b" :: Pattern String)
-- <different hash value>
--
-- Hashing patterns with elements:
--
-- >>> hash (patternWith "root" [pattern "a", pattern "b"] :: Pattern String)
-- <hash value>
--
-- Hash consistency with Eq:
--
-- >>> let p1 = pattern "test" :: Pattern String
-- >>> let p2 = pattern "test" :: Pattern String
-- >>> p1 == p2
-- True
-- >>> hash p1 == hash p2
-- True
--
-- Structure-preserving hashing (different structures produce different hashes):
--
-- >>> let p1 = patternWith "a" [pattern "b", pattern "c"] :: Pattern String
-- >>> let p2 = patternWith "a" [patternWith "b" [pattern "c"]] :: Pattern String
-- >>> hash p1 /= hash p2
-- True
--
-- Using patterns in HashMap:
--
-- >>> import qualified Data.HashMap.Strict as HashMap
-- >>> let m = HashMap.fromList [(pattern "a", 1), (pattern "b", 2)] :: HashMap (Pattern String) Int
-- >>> HashMap.lookup (pattern "a") m
-- Just 1
--
-- Using patterns in HashSet:
--
-- >>> import qualified Data.HashSet as HashSet
-- >>> let s = HashSet.fromList [pattern "a", pattern "b", pattern "c"] :: HashSet (Pattern String)
-- >>> HashSet.member (pattern "a") s
-- True
--
-- === Edge Cases
--
-- **Atomic patterns** (no elements):
--
-- >>> hash (pattern "atom" :: Pattern String)
-- <hash value>
--
-- **Patterns with many elements**:
--
-- >>> let elems = map pattern ["a", "b", "c", "d", "e"]
-- >>> hash (patternWith "root" elems :: Pattern String)
-- <hash value>
--
-- **Deeply nested patterns**:
--
-- >>> let deep = patternWith "level1" [patternWith "level2" [patternWith "level3" [pattern "value"]]]
-- >>> hash (deep :: Pattern String)
-- <hash value>
--
-- **Patterns with same flattened values but different structures**:
--
-- >>> let p1 = patternWith "a" [pattern "b", pattern "c"] :: Pattern String
-- >>> let p2 = patternWith "a" [patternWith "b" [pattern "c"]] :: Pattern String
-- >>> hash p1 /= hash p2
-- True
--
-- === Type Constraint
--
-- The `Hashable` instance requires that the value type `v` has a `Hashable` instance:
--
-- >>> hash (pattern "test" :: Pattern String)  -- String has Hashable instance
-- <hash value>
--
-- If the value type doesn't have a `Hashable` instance, the pattern cannot be hashed:
--
-- >>> -- This would fail to compile if CustomType doesn't have Hashable instance
-- >>> -- hash (pattern customValue :: Pattern CustomType)
--
-- === Performance
--
-- Hash computation is O(n) where n is the number of nodes in the pattern structure.
-- For patterns with up to 1000 nodes, hash computation should complete in under 10 milliseconds.
--
-- Hash-based container operations:
--
-- * `HashMap` lookups: O(1) average-case, O(n) worst-case (with collisions)
-- * `HashSet` membership: O(1) average-case, O(n) worst-case (with collisions)
--
-- === Comparison with Ordered Containers
--
-- Hash-based containers (`HashMap`, `HashSet`) provide O(1) average-case operations
-- but do not maintain sorted order. Ordered containers (`Data.Map`, `Data.Set`) provide
-- O(log n) operations but maintain sorted order. Choose based on whether ordering is
-- needed and performance requirements.
--
instance Hashable v => Hashable (Pattern v) where
  -- | Hash a pattern using structure-preserving hashing.
  --
  -- The hash is computed by hashing the pattern's value first, then its elements
  -- recursively. This ensures that equal patterns (according to `Eq`) produce the
  -- same hash value while providing good distribution.
  --
  -- === Implementation
  --
  -- The implementation follows standard Haskell conventions for recursive types:
  --
  -- @
  -- hashWithSalt s (Pattern v els) = s `hashWithSalt` v `hashWithSalt` els
  -- @
  --
  -- Where `els` is hashed as a list, which recursively hashes each element pattern
  -- using the `Hashable` instance for `[Pattern v]` (which requires `Hashable (Pattern v)`).
  --
  -- === Examples
  --
  -- Hashing with default salt:
  --
  -- >>> hash (pattern "test" :: Pattern String)
  -- <hash value>
  --
  -- Hashing with custom salt:
  --
  -- >>> hashWithSalt 42 (pattern "test" :: Pattern String)
  -- <hash value>
  --
  hashWithSalt s (Pattern v els) = s `hashWithSalt` v `hashWithSalt` els

-- | Functor instance for Pattern.
--
-- Transforms values in patterns while preserving pattern structure (element count,
-- nesting depth, element order). The transformation function is applied recursively
-- to all values in the pattern structure, including values at all nesting levels.
--
-- The Functor instance enables value transformation without manual pattern reconstruction.
-- This is essential for pattern composition, type conversion, and functional transformations
-- that are fundamental to practical pattern manipulation.
--
-- === Structure Preservation
--
-- The Functor instance preserves pattern structure during transformation:
--
-- * Element count: The number of elements remains unchanged
-- * Nesting depth: The nesting structure is preserved
-- * Element order: The order of elements is maintained
--
-- Only the values are transformed; the pattern structure itself remains identical.
--
-- === Functor Laws
--
-- The Functor instance satisfies the standard functor laws, which are verified
-- through property-based testing in the test suite:
--
-- **Identity Law**: For all patterns @p :: Pattern v@,
--
-- @
-- fmap id p = id p
-- @
--
-- This law states that applying the identity function to a pattern produces
-- the exact same pattern. The identity function leaves all values unchanged,
-- so the pattern structure and values remain identical.
--
-- **Composition Law**: For all patterns @p :: Pattern a@ and functions
-- @f :: b -> c@ and @g :: a -> b@,
--
-- @
-- fmap (f . g) p = (fmap f . fmap g) p
-- @
--
-- This law states that applying a composition of two functions to a pattern
-- produces the same result as applying each function sequentially. This enables
-- safe composition of transformations and predictable behavior when chaining
-- multiple transformations.
--
-- Both laws hold for all pattern structures (atomic, with elements, nested)
-- and all value types, as verified by property-based tests.
--
-- === Examples
--
-- Transforming atomic pattern with string value:
--
-- >>> atom = pattern "test"
-- >>> fmap (map toUpper) atom
-- Pattern {value = "TEST", elements = []}
--
-- Transforming pattern with multiple elements:
--
-- >>> elem1 = pattern "hello"
-- >>> elem2 = pattern "world"
-- >>> pattern = patternWith "greeting" [elem1, elem2]
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "GREETING", elements = [Pattern {value = "HELLO", elements = []},Pattern {value = "WORLD", elements = []}]}
--
-- Transforming pattern with integer values:
--
-- >>> elem1 = pattern 5
-- >>> elem2 = pattern 10
-- >>> pattern = patternWith 20 [elem1, elem2]
-- >>> fmap (* 2) pattern
-- Pattern {value = 40, elements = [Pattern {value = 10, elements = []},Pattern {value = 20, elements = []}]}
--
-- Transforming nested pattern structure (3 levels):
--
-- >>> inner = pattern "inner"
-- >>> middle = patternWith "middle" [inner]
-- >>> outer = patternWith "outer" [middle]
-- >>> pattern = patternWith "root" [outer]
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "ROOT", elements = [Pattern {value = "OUTER", elements = [Pattern {value = "MIDDLE", elements = [Pattern {value = "INNER", elements = []}]}]}]}
--
-- Transforming deeply nested pattern structure (4+ levels):
--
-- >>> level4 = pattern "level4"
-- >>> level3 = patternWith "level3" [level4]
-- >>> level2 = patternWith "level2" [level3]
-- >>> level1 = patternWith "level1" [level2]
-- >>> pattern = patternWith "root" [level1]
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "ROOT", elements = [Pattern {value = "LEVEL1", elements = [Pattern {value = "LEVEL2", elements = [Pattern {value = "LEVEL3", elements = [Pattern {value = "LEVEL4", elements = []}]}]}]}]}
--
-- Transforming pattern with varying nesting depths in different branches:
--
-- >>> branch1 = patternWith "b1" [pattern "b1leaf"]
-- >>> branch2 = patternWith "b2" [patternWith "b2mid" [pattern "b2leaf"]]
-- >>> branch3 = pattern "b3"
-- >>> pattern = patternWith "root" [branch1, branch2, branch3]
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "ROOT", elements = [Pattern {value = "B1", elements = [Pattern {value = "B1LEAF", elements = []}]},Pattern {value = "B2", elements = [Pattern {value = "B2MID", elements = [Pattern {value = "B2LEAF", elements = []}]}]},Pattern {value = "B3", elements = []}]}
--
-- Type transformation (String to Int):
--
-- >>> elem1 = pattern "5"
-- >>> elem2 = pattern "10"
-- >>> pattern = patternWith "20" [elem1, elem2]
-- >>> fmap (read :: String -> Int) pattern
-- Pattern {value = 20, elements = [Pattern {value = 5, elements = []},Pattern {value = 10, elements = []}]}
--
-- === Edge Cases
--
-- The Functor instance handles all pattern structures correctly:
--
-- **Atomic patterns** (no elements):
--
-- >>> atom = Pattern { value = "atom", elements = [] }
-- >>> fmap (map toUpper) atom
-- Pattern {value = "ATOM", elements = []}
--
-- **Singular patterns** (one element):
--
-- >>> elem = Pattern { value = "elem", elements = [] }
-- >>> pattern = Pattern { value = "singular", elements = [elem] }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "SINGULAR", elements = [Pattern {value = "ELEM", elements = []}]}
--
-- **Pair patterns** (two elements):
--
-- >>> elem1 = Pattern { value = "first", elements = [] }
-- >>> elem2 = Pattern { value = "second", elements = [] }
-- >>> pattern = Pattern { value = "pair", elements = [elem1, elem2] }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "PAIR", elements = [Pattern {value = "FIRST", elements = []},Pattern {value = "SECOND", elements = []}]}
--
-- **Extended patterns** (many elements):
--
-- >>> elems = [Pattern { value = "a", elements = [] }, Pattern { value = "b", elements = [] }, Pattern { value = "c", elements = [] }]
-- >>> pattern = Pattern { value = "extended", elements = elems }
-- >>> fmap (map toUpper) pattern
-- Pattern {value = "EXTENDED", elements = [Pattern {value = "A", elements = []},Pattern {value = "B", elements = []},Pattern {value = "C", elements = []}]}
--
-- **Type transformations** (Int to String):
--
-- >>> elem1 = Pattern { value = 5, elements = [] }
-- >>> elem2 = Pattern { value = 10, elements = [] }
-- >>> pattern = Pattern { value = 20, elements = [elem1, elem2] }
-- >>> fmap show pattern
-- Pattern {value = "20", elements = [Pattern {value = "5", elements = []},Pattern {value = "10", elements = []}]}
--
instance Functor Pattern where
  fmap f (Pattern v els) = Pattern (f v) (map (fmap f) els)

-- | Applicative instance for Pattern.
--
-- Enables applying functions stored in patterns to values stored in patterns
-- using structure-preserving/zip-like semantics. The Applicative instance
-- provides a way to apply functions in a structured context, extending the
-- capabilities of the Functor instance.
--
-- === Structure-Preserving Semantics
--
-- The Applicative instance uses structure-preserving/zip-like semantics:
--
-- * Root function is applied to root value
-- * Element functions are applied to element values at corresponding positions
-- * Function application is applied recursively to nested patterns
-- * Zip-like truncation handles mismatched element counts (applies up to minimum count)
--
-- This preserves pattern structure during function application, maintaining
-- the decorated sequence model where elements form the pattern itself.
--
-- === Applicative Laws
--
-- The Applicative instance satisfies all Applicative laws:
--
-- **Identity Law**: @pure id <*> v = v@
--
-- Applying the identity function to a pattern produces the same pattern unchanged.
--
-- **Composition Law**: @pure (.) <*> u <*> v <*> w = u <*> (v <*> w)@
--
-- Applying a composition of functions is equivalent to applying each function sequentially.
--
-- **Homomorphism Law**: @pure f <*> pure x = pure (f x)@
--
-- Applying a pure function to a pure value equals pure application.
--
-- **Interchange Law**: @u <*> pure y = pure ($ y) <*> u@
--
-- Applying a function pattern to a pure value equals applying a pure function to the value pattern.
--
-- These laws are verified through property-based testing to ensure mathematical correctness.
--
-- === Consistency with Functor
--
-- The Applicative instance is consistent with the Functor instance:
--
-- @
-- fmap f x = pure f <*> x
-- @
--
-- This relationship ensures that Functor operations can be expressed using
-- Applicative operations, maintaining categorical consistency. This consistency
-- is verified through property-based testing to ensure it holds for all pattern
-- structures (atomic, with elements, nested) and all value type transformations.
--
-- === Examples
--
-- Atomic patterns:
--
-- >>> let f = pure (+1)
-- >>> let x = pure 5
-- >>> f <*> x
-- Pattern {value = 6, elements = []}
--
-- Patterns with elements:
--
-- >>> let fs = patternWith id [pure (*2), pure (+10)]
-- >>> let xs = patternWith 5 [pure 3, pure 7]
-- >>> fs <*> xs
-- Pattern {value = 5, elements = [Pattern {value = 6, elements = []}, Pattern {value = 17, elements = []}]}
--
-- Nested patterns:
--
-- >>> let fs = patternWith id [patternWith (*2) [pure (*3)], patternWith (+1) []]
-- >>> let xs = patternWith 1 [patternWith 2 [pure 3], patternWith 4 []]
-- >>> fs <*> xs
-- Pattern {value = 1, elements = [Pattern {value = 4, elements = [Pattern {value = 9, elements = []}]}, Pattern {value = 5, elements = []}]}
--
-- Mismatched element counts (zip-like truncation):
--
-- >>> let fs = patternWith id [pure (*2)]  -- 1 element
-- >>> let xs = patternWith 5 [pure 3, pure 7]   -- 2 elements
-- >>> fs <*> xs
-- Pattern {value = 5, elements = [Pattern {value = 6, elements = []}]}
--
-- === Edge Cases
--
-- The Applicative instance handles all pattern structures correctly:
--
-- **Atomic patterns**: Function and value are both atomic, result is atomic
-- **Patterns with elements**: Functions and values have matching elements, applied positionally
-- **Nested patterns**: Functions and values have matching nesting, applied recursively
-- **Mismatched structures**: Zip-like truncation applies up to minimum element count
--
instance Applicative Pattern where
  -- | Wrap a value in an atomic pattern.
  --
  -- Creates a pattern with the provided value and an empty elements list.
  -- This enables values to be used in applicative operations with patterns.
  --
  -- === Examples
  --
  -- >>> pure 5
  -- Pattern {value = 5, elements = []}
  --
  -- >>> pure "hello"
  -- Pattern {value = "hello", elements = []}
  --
  -- >>> pure (+1) <*> pure 5
  -- Pattern {value = 6, elements = []}
  --
  pure x = Pattern x []
  
  -- | Apply functions stored in a pattern to values stored in a pattern.
  --
  -- Uses structure-preserving/zip-like semantics: applies functions to values
  -- at corresponding positions (root to root, element to element). When element
  -- counts differ, applies functions to values up to the minimum element count,
  -- ignoring extra elements in the longer pattern.
  --
  -- === Structure-Preserving Semantics
  --
  -- The operator preserves pattern structure during function application:
  --
  -- * Root function is applied to root value
  -- * Element functions are applied to element values at corresponding positions
  -- * Function application is applied recursively to nested patterns
  -- * Zip-like truncation handles mismatched element counts
  --
  -- === Examples
  --
  -- Atomic patterns:
  --
  -- >>> let f = pure (+1)
  -- >>> let x = pure 5
  -- >>> f <*> x
  -- Pattern {value = 6, elements = []}
  --
  -- Patterns with elements:
  --
  -- >>> let fs = patternWith id [pure (*2), pure (+10)]
  -- >>> let xs = patternWith 5 [pure 3, pure 7]
  -- >>> fs <*> xs
  -- Pattern {value = 5, elements = [Pattern {value = 6, elements = []}, Pattern {value = 17, elements = []}]}
  --
  -- Mismatched element counts (truncation):
  --
  -- >>> let fs = patternWith id [pure (*2)]  -- 1 element
  -- >>> let xs = patternWith 5 [pure 3, pure 7]   -- 2 elements
  -- >>> fs <*> xs
  -- Pattern {value = 5, elements = [Pattern {value = 6, elements = []}]}
  --
  Pattern f fs <*> Pattern x xs = 
    Pattern (f x) (applyElements fs xs)
    where
      -- Apply element functions to element values
      -- If one list is empty (atomic pattern), broadcast to all elements of the other
      -- This handles the case where pure function/value is applied to pattern with elements
      applyElements [] ys = map (pure f <*>) ys  -- pure function broadcast to all value elements
      applyElements ys [] = map (<*> pure x) ys  -- pure value broadcast to all function elements
      applyElements fs' xs' = zipWith (<*>) fs' xs'  -- zip-like truncation: apply up to minimum length
      
      -- Edge case handling:
      -- * Empty elements lists: Both patterns atomic, result is atomic (handled by root application)
      -- * Mismatched element counts: Zip-like truncation applies functions to values up to minimum count
      -- * Deeply nested patterns: Recursive application handles all nesting levels
      -- * Atomic with elements: Broadcasting handles pure function/value with pattern elements

-- | Foldable instance for Pattern.
--
-- Enables folding over all values in a pattern structure, including the pattern's
-- own value and all element values at all nesting levels. The Foldable instance
-- provides value aggregation capabilities, allowing developers to compute statistics,
-- combine values, and perform calculations over pattern structures without manually
-- traversing the pattern tree.
--
-- === Value Aggregation
--
-- The Foldable instance processes all values in the pattern structure:
--
-- * The pattern's own value is included in folding operations
-- * All element values are processed recursively
-- * Values from all nesting levels are included
--
-- This enables efficient aggregation operations like summing integers, concatenating
-- strings, counting elements, or computing custom statistics over pattern values.
--
-- === Folding Order
--
-- The @foldr@ operation processes values in right-to-left order:
--
-- * Element values are processed first (right-to-left through the elements list)
-- * The pattern's own value is processed last
--
-- This order ensures that when building data structures or applying operations that
-- depend on processing order, the pattern's own value is combined with the already
-- processed element values.
--
-- === Foldable Laws
--
-- The Foldable instance satisfies standard foldable laws and properties. These laws
-- ensure mathematical correctness and predictable behavior for all foldable operations.
--
-- **Law 1: toList extracts all values**
--
-- For any pattern @p :: Pattern a@, @toList p@ extracts all values from the pattern
-- structure as a flat list. The pattern's own value and all element values at all
-- nesting levels are included exactly once:
--
-- @
-- toList (Pattern v els) = v : concatMap toList els
-- @
--
-- This law ensures that @toList@ processes all values in the pattern structure
-- without duplication or omission.
--
-- **Law 2: foldr processes all values**
--
-- For any pattern @p :: Pattern a@, function @f :: a -> b -> b@, and initial value @z :: b@,
-- @foldr f z p@ processes all values in the pattern structure exactly once:
--
-- @
-- foldr f z (Pattern v els) = f v (foldr (\e acc -> foldr f acc e) z els)
-- @
--
-- This law ensures that @foldr@ processes the pattern's own value and all element
-- values recursively, maintaining right-associative semantics.
--
-- **Law 3: foldl processes all values**
--
-- For any pattern @p :: Pattern a@, function @f :: b -> a -> b@, and initial value @z :: b@,
-- @foldl f z p@ processes all values in the pattern structure exactly once:
--
-- @
-- foldl f z (Pattern v els) = foldl (\acc e -> foldl f acc e) (f z v) els
-- @
--
-- This law ensures that @foldl@ processes the pattern's own value first, then all
-- element values recursively, maintaining left-associative semantics.
--
-- **Law 4: foldMap with monoids**
--
-- For any pattern @p :: Pattern a@, function @f :: a -> m@ where @m@ is a monoid,
-- @foldMap f p@ maps all values to monoids and combines them:
--
-- @
-- foldMap f (Pattern v els) = f v <> foldMap (\e -> foldMap f e) els
-- @
--
-- This law ensures that @foldMap@ processes all values and combines them using
-- monoid operations, enabling efficient aggregation.
--
-- **Law 5: Relationship between toList and foldr**
--
-- For any pattern @p :: Pattern a@, @toList p@ is equivalent to @foldr (:) [] p@:
--
-- @
-- toList p = foldr (:) [] p
-- @
--
-- This law ensures that @toList@ is correctly derived from @foldr@ and extracts
-- all values as a flat list.
--
-- **Law 6: Commutative operations produce same results**
--
-- For any pattern @p :: Pattern a@ and commutative operation @f@, @foldr f z p@
-- and @foldl f z p@ produce the same result:
--
-- @
-- foldr (+) 0 p = foldl (+) 0 p  -- for commutative operations
-- @
--
-- This law ensures that for commutative operations like addition and multiplication,
-- both folding directions produce identical results.
--
-- **Property: Order preservation**
--
-- For any pattern @p :: Pattern a@, multiple calls to @toList p@ produce the same
-- result in the same order:
--
-- @
-- toList p == toList p  -- always true, order is preserved
-- @
--
-- This property ensures that @toList@ is deterministic and preserves the order
-- of values in the pattern structure.
--
-- **Property: All values processed**
--
-- For any pattern @p :: Pattern a@, the number of values in @toList p@ equals the
-- total number of values in the pattern structure (pattern's value plus all element
-- values at all nesting levels):
--
-- @
-- length (toList p) = countValues p
-- @
--
-- where @countValues@ manually counts all values in the pattern structure.
--
-- These laws and properties are verified through property-based testing to ensure
-- mathematical correctness for all pattern structures (atomic, with elements, nested).
--
-- === Examples
--
-- Summing integer values from an atomic pattern:
--
-- >>> atom = pattern 5
-- >>> foldr (+) 0 atom
-- 5
--
-- Summing integer values from a pattern with multiple elements:
--
-- >>> elem1 = pattern 10
-- >>> elem2 = pattern 20
-- >>> pattern = patternWith 100 [elem1, elem2]
-- >>> foldr (+) 0 pattern
-- 130
--
-- Concatenating string values from a pattern:
--
-- >>> elem1 = pattern "hello"
-- >>> elem2 = pattern "world"
-- >>> pattern = patternWith "greeting" [elem1, elem2]
-- >>> foldr (++) "" pattern
-- "greetinghelloworld"
--
-- Summing values from a nested pattern structure:
--
-- >>> inner = pattern 1
-- >>> middle = patternWith 2 [inner]
-- >>> outer = patternWith 3 [middle]
-- >>> pattern = patternWith 4 [outer]
-- >>> foldr (+) 0 pattern
-- 10
--
-- Counting all values in a pattern:
--
-- >>> elem1 = pattern "a"
-- >>> elem2 = pattern "b"
-- >>> pattern = patternWith "root" [elem1, elem2]
-- >>> foldr (\_ acc -> acc + 1) 0 pattern
-- 3
--
-- === Edge Cases
--
-- The Foldable instance handles all pattern structures correctly:
--
-- **Atomic patterns** (no elements):
--
-- >>> atom = pattern 42
-- >>> foldr (+) 0 atom
-- 42
-- >>> toList atom
-- [42]
-- >>> foldl (+) 0 atom
-- 42
-- >>> getSum (foldMap Sum atom)
-- 42
--
-- **Patterns with empty elements list**:
--
-- >>> pattern = pattern 10
-- >>> foldr (+) 0 pattern
-- 10
-- >>> toList pattern
-- [10]
-- >>> foldl (+) 0 pattern
-- 10
--
-- **Singular patterns** (one element):
--
-- >>> elem = pattern 5
-- >>> pattern = patternWith 10 [elem]
-- >>> foldr (+) 0 pattern
-- 15
-- >>> toList pattern
-- [10, 5]
-- >>> foldl (+) 0 pattern
-- 15
--
-- **Patterns with many elements**:
--
-- >>> elems = map pattern [1..5]
-- >>> pattern = patternWith 100 elems
-- >>> foldr (+) 0 pattern
-- 115
-- >>> length (toList pattern)
-- 6
-- >>> head (toList pattern)
-- 100
--
-- **Nested patterns** (multiple levels):
--
-- >>> level3 = pattern 1
-- >>> level2 = patternWith 2 [level3]
-- >>> level1 = patternWith 3 [level2]
-- >>> pattern = patternWith 4 [level1]
-- >>> foldr (+) 0 pattern
-- 10
-- >>> toList pattern
-- [4, 3, 2, 1]
--
-- **Deep nesting** (3+ levels):
--
-- >>> level4 = pattern 1
-- >>> level3 = patternWith 2 [level4]
-- >>> level2 = patternWith 3 [level3]
-- >>> level1 = patternWith 4 [level2]
-- >>> pattern = patternWith 5 [level1]
-- >>> foldr (+) 0 pattern
-- 15
-- >>> toList pattern
-- [5, 4, 3, 2, 1]
--
-- **Patterns with different value types**:
--
-- String values:
--
-- >>> elem1 = pattern "hello"
-- >>> elem2 = pattern "world"
-- >>> pattern = patternWith "greeting" [elem1, elem2]
-- >>> foldr (++) "" pattern
-- "greetinghelloworld"
-- >>> toList pattern
-- ["greeting", "hello", "world"]
--
-- Integer values:
--
-- >>> elem1 = pattern 10
-- >>> elem2 = pattern 20
-- >>> pattern = patternWith 100 [elem1, elem2]
-- >>> foldr (+) 0 pattern
-- 130
-- >>> getSum (foldMap Sum pattern)
-- 130
--
-- **Order preservation**:
--
-- >>> elem1 = pattern "first"
-- >>> elem2 = pattern "second"
-- >>> elem3 = pattern "third"
-- >>> pattern = patternWith "root" [elem1, elem2, elem3]
-- >>> toList pattern
-- ["root", "first", "second", "third"]
-- >>> foldr (:) [] pattern
-- ["root", "first", "second", "third"]
--
-- **Nested patterns with varying depths**:
--
-- >>> branch1 = patternWith 10 [pattern 1]
-- >>> branch2 = patternWith 20 [patternWith 2 [pattern 3]]
-- >>> branch3 = pattern 30
-- >>> pattern = patternWith 100 [branch1, branch2, branch3]
-- >>> foldr (+) 0 pattern
-- 166
-- >>> length (toList pattern)
-- 7
--
instance Foldable Pattern where
  -- | Right-associative fold over pattern values.
  --
  -- Processes all values in the pattern structure, including the pattern's own value
  -- and all element values at all nesting levels. Element values are processed first
  -- (right-to-left through the elements list), then the pattern's own value is combined
  -- with the accumulated result.
  --
  -- === Processing Order
  --
  -- The @foldr@ operation processes values in a specific order:
  --
  -- 1. Element values are processed first (right-to-left through the elements list)
  -- 2. The pattern's own value is processed last (combined with accumulated elements)
  --
  -- When building lists with @foldr (:) []@ or using @toList@, this results in the
  -- pattern's own value appearing first in the list, followed by element values in order.
  --
  -- === Examples
  --
  -- Atomic pattern:
  --
  -- >>> atom = pattern 5
  -- >>> foldr (+) 0 atom
  -- 5
  --
  -- Pattern with multiple elements (order: elements first, then pattern's value):
  --
  -- >>> elem1 = pattern 10
  -- >>> elem2 = pattern 20
  -- >>> pattern = patternWith 100 [elem1, elem2]
  -- >>> foldr (+) 0 pattern
  -- 130
  --
  -- Building a list preserves order (pattern's value first, then elements):
  --
  -- >>> toList pattern
  -- [100, 10, 20]
  --
  -- Nested pattern structure:
  --
  -- >>> inner = pattern 1
  -- >>> middle = patternWith 2 [inner]
  -- >>> pattern = patternWith 3 [middle]
  -- >>> foldr (+) 0 pattern
  -- 6
  --
  -- Order preservation in nested structures:
  --
  -- >>> toList pattern
  -- [3, 2, 1]
  --
  -- === Right-Associativity
  --
  -- The @foldr@ operation is right-associative, meaning operations are grouped from
  -- right to left. For commutative operations like addition, this produces the same
  -- result as left-associative folding. For non-commutative operations, the order
  -- matters and is preserved as described above.
  --
  -- Example with commutative operation (addition):
  --
  -- >>> elem1 = pattern 10
  -- >>> elem2 = pattern 20
  -- >>> pattern = patternWith 100 [elem1, elem2]
  -- >>> foldr (+) 0 pattern
  -- 130
  -- >>> foldr (+) 0 (toList pattern)
  -- 130
  --
  -- Example with non-commutative operation (list building):
  --
  -- >>> elem1 = pattern "a"
  -- >>> elem2 = pattern "b"
  -- >>> pattern = patternWith "root" [elem1, elem2]
  -- >>> toList pattern
  -- ["root", "a", "b"]
  --
  foldr f z (Pattern v els) = f v (foldr (\e acc -> foldr f acc e) z els)
  
  -- | Left-associative fold over pattern values.
  --
  -- Processes all values in the pattern structure, including the pattern's own value
  -- and all element values at all nesting levels. Values are processed in left-to-right
  -- order: the pattern's own value is processed first, then element values are processed
  -- recursively from left to right.
  --
  -- === Processing Order
  --
  -- The @foldl@ operation processes values in a specific order:
  --
  -- 1. The pattern's own value is processed first (combined with initial accumulator)
  -- 2. Element values are processed recursively from left to right
  --
  -- This order ensures that when applying operations that require strict left-to-right
  -- evaluation, the pattern's own value is combined first, followed by element values
  -- in their natural order.
  --
  -- === Examples
  --
  -- Atomic pattern:
  --
  -- >>> atom = pattern 5
  -- >>> foldl (+) 0 atom
  -- 5
  --
  -- Pattern with multiple elements (order: pattern's value first, then elements left-to-right):
  --
  -- >>> elem1 = pattern 10
  -- >>> elem2 = pattern 20
  -- >>> pattern = patternWith 100 [elem1, elem2]
  -- >>> foldl (+) 0 pattern
  -- 130
  --
  -- Computing running total with left-associative operations:
  --
  -- >>> foldl (-) 0 pattern
  -- -130
  --
  -- Nested pattern structure:
  --
  -- >>> inner = pattern 1
  -- >>> middle = patternWith 2 [inner]
  -- >>> pattern = patternWith 3 [middle]
  -- >>> foldl (+) 0 pattern
  -- 6
  --
  -- === Left-Associativity
  --
  -- The @foldl@ operation is left-associative, meaning operations are grouped from
  -- left to right. For commutative operations like addition, this produces the same
  -- result as right-associative folding. For non-commutative operations, the order
  -- matters and is preserved as described above.
  --
  -- Example with commutative operation (addition):
  --
  -- >>> elem1 = Pattern { value = 10, elements = [] }
  -- >>> elem2 = Pattern { value = 20, elements = [] }
  -- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
  -- >>> foldl (+) 0 pattern
  -- 130
  -- >>> foldl (+) 0 (toList pattern)
  -- 130
  --
  -- Example with non-commutative operation (subtraction):
  --
  -- >>> elem1 = Pattern { value = 5, elements = [] }
  -- >>> elem2 = Pattern { value = 3, elements = [] }
  -- >>> pattern = Pattern { value = 10, elements = [elem1, elem2] }
  -- >>> foldl (-) 0 pattern
  -- -18
  --
  foldl f z (Pattern v els) = Prelude.foldl (\acc e -> foldl f acc e) (f z v) els
  
  -- | Map values to monoids and combine them efficiently.
  --
  -- Maps each value in the pattern structure to a monoid and combines them
  -- using monoid operations. This provides a declarative approach for common
  -- aggregation patterns like summing, concatenating, or counting without
  -- explicitly writing fold functions.
  --
  -- The @foldMap@ operation processes all values in the pattern structure,
  -- including the pattern's own value and all element values at all nesting
  -- levels. Values are mapped to monoids and combined using the monoid's
  -- @mappend@ operation (or @<>@).
  --
  -- === Examples
  --
  -- Summing integer values with Sum monoid:
  --
  -- >>> elem1 = Pattern { value = 10, elements = [] }
  -- >>> elem2 = Pattern { value = 20, elements = [] }
  -- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
  -- >>> getSum (foldMap Sum pattern)
  -- 130
  --
  -- Concatenating string values with list monoid:
  --
  -- >>> elem1 = Pattern { value = "hello", elements = [] }
  -- >>> elem2 = Pattern { value = "world", elements = [] }
  -- >>> pattern = Pattern { value = "greeting", elements = [elem1, elem2] }
  -- >>> foldMap (: []) pattern
  -- ["greeting", "hello", "world"]
  --
  -- Logical AND with All monoid:
  --
  -- >>> elem1 = Pattern { value = True, elements = [] }
  -- >>> elem2 = Pattern { value = True, elements = [] }
  -- >>> pattern = Pattern { value = True, elements = [elem1, elem2] }
  -- >>> getAll (foldMap All pattern)
  -- True
  --
  -- Nested pattern structure:
  --
  -- >>> inner = Pattern { value = 1, elements = [] }
  -- >>> middle = Pattern { value = 2, elements = [inner] }
  -- >>> pattern = Pattern { value = 3, elements = [middle] }
  -- >>> getSum (foldMap Sum pattern)
  -- 6
  --
  -- === Monoid Operations
  --
  -- The @foldMap@ operation uses monoid operations to combine mapped values:
  --
  -- * @Sum@ monoid: Addition for numeric values
  -- * @Product@ monoid: Multiplication for numeric values
  -- * @All@ monoid: Logical AND for boolean values
  -- * @Any@ monoid: Logical OR for boolean values
  -- * List monoid: Concatenation for lists
  -- * Custom monoids: Any type with a Monoid instance
  --
  -- === Efficiency
  --
  -- The @foldMap@ operation is implemented efficiently using the pattern's
  -- @foldr@ implementation. For monoids that support efficient combination,
  -- this provides optimal performance for aggregation operations.
  --
  -- Example with Sum monoid (efficient):
  --
  -- >>> getSum (foldMap Sum (Pattern { value = 5, elements = [] }))
  -- 5
  --
  -- Example with list monoid (efficient concatenation):
  --
  -- >>> foldMap (: []) (Pattern { value = "test", elements = [] })
  -- ["test"]
  --
  -- Note: @foldMap@ is automatically derived from @foldr@ and works correctly
  -- for all pattern structures. The default implementation processes all values
  -- in the pattern structure, including the pattern's own value and all element
  -- values at all nesting levels.
  
  -- Note: @toList@ is automatically derived from @foldr@ and extracts all values
  -- as a flat list. The pattern's own value and all element values at all
  -- nesting levels are included in the result.

-- | Traversable instance for Pattern.
--
-- Enables effectful traversal over all values in a pattern structure while
-- preserving pattern structure (element count, nesting depth, element order).
-- The Traversable instance provides the @traverse@ operation that applies
-- effectful functions to all values in the pattern structure, combining effects
-- using applicative semantics.
--
-- === Effectful Traversal
--
-- The Traversable instance processes all values in the pattern structure:
--
-- * The pattern's own value is processed first
-- * All element values are processed recursively
-- * Values from all nesting levels are included
-- * Effects are combined using applicative semantics
--
-- This enables operations like validation, state threading, IO operations, and
-- error handling over pattern values while maintaining pattern structure.
--
-- === Structure Preservation
--
-- The Traversable instance preserves pattern structure during traversal:
--
-- * Element count: The number of elements remains unchanged
-- * Nesting depth: The nesting structure is preserved
-- * Element order: The order of elements is maintained
--
-- Only the values are transformed; the pattern structure itself remains identical.
--
-- === Effect Combination
--
-- Effects are combined using standard applicative semantics for each applicative functor:
--
-- * **Maybe**: Short-circuits to Nothing if any value produces Nothing
-- * **Either**: Short-circuits to Left with first error if any value produces Left
-- * **[]**: Collects all results from all values
-- * **Identity**: Preserves structure without effects
-- * **IO**: Performs all IO operations and combines results
-- * **State**: Threads state through all values
--
-- === Traversable Laws
--
-- The Traversable instance satisfies the standard traversable laws, which are verified
-- through property-based testing in the test suite:
--
-- **Naturality Law**: For any applicative transformation @t@ and function @f@,
--
-- @
-- t . traverse f = traverse (t . f)
-- @
--
-- This law ensures that applicative transformations commute with traversal.
--
-- **Identity Law**: For all patterns @p :: Pattern a@,
--
-- @
-- traverse Identity p = Identity p
-- @
--
-- This law states that traversing with the Identity applicative functor produces
-- the same pattern wrapped in Identity.
--
-- **Composition Law**: For all patterns @p :: Pattern a@ and functions @f@ and @g@,
--
-- @
-- traverse (Compose . fmap g . f) p = Compose . fmap (traverse g) . traverse f $ p
-- @
--
-- This law ensures that composition of traversals equals sequential traversal.
--
-- All laws hold for all pattern structures (atomic, with elements, nested) and all
-- value types, as verified by property-based tests.
--
-- === Examples
--
-- Traversing atomic pattern with Identity (no effects):
--
-- >>> atom = Pattern { value = "test", elements = [] }
-- >>> traverse Identity atom
-- Identity (Pattern {value = "test", elements = []})
--
-- Traversing atomic pattern with Maybe (validation):
--
-- >>> let validate x = if x > 0 then Just x else Nothing
-- >>> traverse validate (Pattern { value = 5, elements = [] })
-- Just (Pattern {value = 5, elements = []})
--
-- >>> traverse validate (Pattern { value = -3, elements = [] })
-- Nothing
--
-- Traversing atomic pattern with Either (error handling):
--
-- >>> let validate x = if x > 0 then Right x else Left ("Invalid: " ++ show x)
-- >>> traverse validate (Pattern { value = 5, elements = [] })
-- Right (Pattern {value = 5, elements = []})
--
-- >>> traverse validate (Pattern { value = -3, elements = [] })
-- Left "Invalid: -3"
--
-- Traversing pattern with multiple elements:
--
-- >>> let validate x = if x > 0 then Just x else Nothing
-- >>> elem1 = Pattern { value = 5, elements = [] }
-- >>> elem2 = Pattern { value = 10, elements = [] }
-- >>> pattern = Pattern { value = 20, elements = [elem1, elem2] }
-- >>> traverse validate pattern
-- Just (Pattern {value = 20, elements = [Pattern {value = 5, elements = []},Pattern {value = 10, elements = []}]})
--
-- Traversing nested pattern structure:
--
-- >>> let validate x = if x > 0 then Just x else Nothing
-- >>> inner = Pattern { value = 1, elements = [] }
-- >>> middle = Pattern { value = 2, elements = [inner] }
-- >>> outer = Pattern { value = 3, elements = [middle] }
-- >>> pattern = Pattern { value = 4, elements = [outer] }
-- >>> traverse validate pattern
-- Just (Pattern {value = 4, elements = [Pattern {value = 3, elements = [Pattern {value = 2, elements = [Pattern {value = 1, elements = []}]}]}]})
--
-- === Edge Cases
--
-- The Traversable instance handles all pattern structures correctly:
--
-- **Atomic patterns** (no elements):
--
-- >>> traverse Identity (Pattern { value = "atom", elements = [] })
-- Identity (Pattern {value = "atom", elements = []})
--
-- **Singular patterns** (one element):
--
-- >>> elem = Pattern { value = "elem", elements = [] }
-- >>> pattern = Pattern { value = "singular", elements = [elem] }
-- >>> traverse Identity pattern
-- Identity (Pattern {value = "singular", elements = [Pattern {value = "elem", elements = []}]})
--
-- **Patterns with many elements**:
--
-- >>> elems = [Pattern { value = "a", elements = [] }, Pattern { value = "b", elements = [] }]
-- >>> pattern = Pattern { value = "root", elements = elems }
-- >>> traverse Identity pattern
-- Identity (Pattern {value = "root", elements = [Pattern {value = "a", elements = []},Pattern {value = "b", elements = []}]})
--
-- **Deep nesting** (3+ levels):
--
-- >>> level3 = Pattern { value = "level3", elements = [] }
-- >>> level2 = Pattern { value = "level2", elements = [level3] }
-- >>> level1 = Pattern { value = "level1", elements = [level2] }
-- >>> pattern = Pattern { value = "root", elements = [level1] }
-- >>> traverse Identity pattern
-- Identity (Pattern {value = "root", elements = [Pattern {value = "level1", elements = [Pattern {value = "level2", elements = [Pattern {value = "level3", elements = []}]}]}]})
--
-- === Validation Use Cases
--
-- The Traversable instance enables validation of pattern values using Maybe or Either
-- applicative functors. Validation functions can check values and return success or
-- failure, with effects combined using applicative semantics.
--
-- **Validation with Maybe** (simple success/failure):
--
-- >>> let validate x = if x > 0 then Just x else Nothing
-- >>> elem1 = Pattern { value = 5, elements = [] }
-- >>> elem2 = Pattern { value = 10, elements = [] }
-- >>> pattern = Pattern { value = 20, elements = [elem1, elem2] }
-- >>> traverse validate pattern
-- Just (Pattern {value = 20, elements = [Pattern {value = 5, elements = []},Pattern {value = 10, elements = []}]})
--
-- >>> let validate x = if x > 0 then Just x else Nothing
-- >>> elem1 = Pattern { value = 5, elements = [] }
-- >>> elem2 = Pattern { value = -3, elements = [] }
-- >>> pattern = Pattern { value = 20, elements = [elem1, elem2] }
-- >>> traverse validate pattern
-- Nothing
--
-- **Validation with Either** (success with error messages):
--
-- >>> let validate x = if x > 0 then Right x else Left ("Invalid: " ++ show x)
-- >>> elem1 = Pattern { value = 5, elements = [] }
-- >>> elem2 = Pattern { value = 10, elements = [] }
-- >>> pattern = Pattern { value = 20, elements = [elem1, elem2] }
-- >>> traverse validate pattern
-- Right (Pattern {value = 20, elements = [Pattern {value = 5, elements = []},Pattern {value = 10, elements = []}]})
--
-- >>> let validate x = if x > 0 then Right x else Left ("Invalid: " ++ show x)
-- >>> elem1 = Pattern { value = 5, elements = [] }
-- >>> elem2 = Pattern { value = -3, elements = [] }
-- >>> pattern = Pattern { value = 20, elements = [elem1, elem2] }
-- >>> traverse validate pattern
-- Left "Invalid: -3"
--
-- **Validation on nested patterns**:
--
-- >>> let validate x = if x > 0 then Just x else Nothing
-- >>> inner = Pattern { value = 1, elements = [] }
-- >>> middle = Pattern { value = 2, elements = [inner] }
-- >>> outer = Pattern { value = 3, elements = [middle] }
-- >>> pattern = Pattern { value = 4, elements = [outer] }
-- >>> traverse validate pattern
-- Just (Pattern {value = 4, elements = [Pattern {value = 3, elements = [Pattern {value = 2, elements = [Pattern {value = 1, elements = []}]}]}]})
--
-- >>> let validate x = if x > 0 then Just x else Nothing
-- >>> inner = Pattern { value = -1, elements = [] }
-- >>> middle = Pattern { value = 2, elements = [inner] }
-- >>> outer = Pattern { value = 3, elements = [middle] }
-- >>> pattern = Pattern { value = 4, elements = [outer] }
-- >>> traverse validate pattern
-- Nothing
--
-- === Error Handling Patterns
--
-- The Traversable instance supports two error handling patterns:
--
-- **Maybe pattern**: Use when you only need to know if validation succeeded or failed.
-- Short-circuits to Nothing on first failure. Useful for simple validation where error
-- messages are not needed.
--
-- **Either pattern**: Use when you need error messages explaining why validation failed.
-- Short-circuits to Left with first error encountered. Useful for validation where
-- detailed error reporting is required.
--
-- Both patterns ensure that validation fails if any value at any nesting level is invalid,
-- providing comprehensive validation coverage for entire pattern structures.
--
instance Traversable Pattern where
  -- | Effectful traversal over pattern values.
  --
  -- Applies an effectful function to all values in the pattern structure while
  -- preserving pattern structure. The function is applied to the pattern's own
  -- value first, then recursively to all element values at all nesting levels.
  -- Effects are combined using applicative semantics.
  --
  -- === Processing Order
  --
  -- The @traverse@ operation processes values in a specific order:
  --
  -- 1. The pattern's own value is processed first
  -- 2. Element values are processed recursively from left to right
  --
  -- This order ensures that when building data structures or applying operations
  -- that depend on processing order, the pattern's own value is processed first,
  -- followed by element values in their natural order.
  --
  -- === Examples
  --
  -- Atomic pattern:
  --
  -- >>> traverse Identity (pattern 5)
  -- Identity (Pattern {value = 5, elements = []})
  --
  -- Pattern with multiple elements:
  --
  -- >>> let validate x = if x > 0 then Just x else Nothing
  -- >>> elem1 = pattern 5
  -- >>> elem2 = pattern 10
  -- >>> pattern = patternWith 20 [elem1, elem2]
  -- >>> traverse validate pattern
  -- Just (Pattern {value = 20, elements = [Pattern {value = 5, elements = []},Pattern {value = 10, elements = []}]})
  --
  -- Nested pattern structure:
  --
  -- >>> let validate x = if x > 0 then Just x else Nothing
  -- >>> inner = pattern 1
  -- >>> middle = patternWith 2 [inner]
  -- >>> pattern = patternWith 3 [middle]
  -- >>> traverse validate pattern
  -- Just (Pattern {value = 3, elements = [Pattern {value = 2, elements = [Pattern {value = 1, elements = []}]}]})
  --
  traverse f (Pattern v els) = 
    Pattern <$> f v <*> traverse (traverse f) els
  
  -- | Sequence applicative effects from a pattern.
  --
  -- Converts a pattern containing applicative values into an applicative
  -- value containing a pattern. Effects are combined using applicative semantics.
  -- This is equivalent to @traverse id@.
  --
  -- === Effect Sequencing
  --
  -- The @sequenceA@ operation processes all values in the pattern structure:
  --
  -- * The pattern's own value is processed first
  -- * All element values are processed recursively
  -- * Values from all nesting levels are included
  -- * Effects are combined using applicative semantics
  --
  -- This enables collecting effects from pattern values and working with
  -- effectful patterns in a structured way.
  --
  -- === Structure Preservation
  --
  -- The @sequenceA@ operation preserves pattern structure during sequencing:
  --
  -- * Element count: The number of elements remains unchanged
  -- * Nesting depth: The nesting structure is preserved
  -- * Element order: The order of elements is maintained
  --
  -- Only the values are unwrapped from their applicative contexts; the pattern
  -- structure itself remains identical.
  --
  -- === Effect Combination
  --
  -- Effects are combined using standard applicative semantics for each applicative functor:
  --
  -- * **Maybe**: Returns Just pattern if all values are Just, Nothing otherwise (short-circuits on first Nothing)
  -- * **Either**: Returns Right pattern if all values are Right, Left with first error otherwise (short-circuits on first Left)
  -- * **[]**: Collects all combinations of values
  -- * **Identity**: Unwraps Identity values
  -- * **IO**: Performs all IO operations and combines results
  -- * **State**: Threads state through all values
  --
  -- === Relationship to traverse
  --
  -- The @sequenceA@ operation is equivalent to @traverse id@:
  --
  -- @
  -- sequenceA = traverse id
  -- @
  --
  -- This relationship ensures that sequencing effects is consistent with
  -- effectful traversal operations.
  --
  -- === Examples
  --
  -- Sequencing pattern containing Identity values:
  --
  -- >>> atom = pattern (Identity "test")
  -- >>> sequenceA atom
  -- Identity (Pattern {value = "test", elements = []})
  --
  -- Sequencing pattern containing Maybe values (all Just):
  --
  -- >>> elem1 = pattern (Just 5)
  -- >>> elem2 = pattern (Just 10)
  -- >>> pattern = patternWith (Just 20) [elem1, elem2]
  -- >>> sequenceA pattern
  -- Just (Pattern {value = 20, elements = [Pattern {value = 5, elements = []},Pattern {value = 10, elements = []}]})
  --
  -- Sequencing pattern containing Maybe values (one Nothing):
  --
  -- >>> elem1 = pattern (Just 5)
  -- >>> elem2 = pattern Nothing
  -- >>> pattern = patternWith (Just 20) [elem1, elem2]
  -- >>> sequenceA pattern
  -- Nothing
  --
  -- Sequencing pattern containing Either values (all Right):
  --
  -- >>> elem1 = pattern (Right 5)
  -- >>> elem2 = pattern (Right 10)
  -- >>> pattern = patternWith (Right 20) [elem1, elem2]
  -- >>> sequenceA pattern
  -- Right (Pattern {value = 20, elements = [Pattern {value = 5, elements = []},Pattern {value = 10, elements = []}]})
  --
  -- Sequencing pattern containing Either values (one Left):
  --
  -- >>> elem1 = pattern (Right 5)
  -- >>> elem2 = pattern (Left "error")
  -- >>> pattern = patternWith (Right 20) [elem1, elem2]
  -- >>> sequenceA pattern
  -- Left "error"
  --
  -- Sequencing nested pattern structure:
  --
  -- >>> inner = pattern (Just 1)
  -- >>> middle = patternWith (Just 2) [inner]
  -- >>> outer = patternWith (Just 3) [middle]
  -- >>> pattern = patternWith (Just 4) [outer]
  -- >>> sequenceA pattern
  -- Just (Pattern {value = 4, elements = [Pattern {value = 3, elements = [Pattern {value = 2, elements = [Pattern {value = 1, elements = []}]}]}]})
  --
  -- === Edge Cases
  --
  -- The @sequenceA@ operation handles all pattern structures correctly:
  --
  -- **Atomic patterns** (no elements):
  --
  -- >>> sequenceA (pattern (Just 5))
  -- Just (Pattern {value = 5, elements = []})
  --
  -- **Singular patterns** (one element):
  --
  -- >>> elem = pattern (Just 5)
  -- >>> pattern = patternWith (Just 10) [elem]
  -- >>> sequenceA pattern
  -- Just (Pattern {value = 10, elements = [Pattern {value = 5, elements = []}]})
  --
  -- **Patterns with many elements**:
  --
  -- >>> elems = [pattern (Just 1), pattern (Just 2)]
  -- >>> pattern = patternWith (Just 100) elems
  -- >>> sequenceA pattern
  -- Just (Pattern {value = 100, elements = [Pattern {value = 1, elements = []},Pattern {value = 2, elements = []}]})
  --
  -- **Deep nesting** (3+ levels):
  --
  -- >>> level3 = pattern (Just 1)
  -- >>> level2 = patternWith (Just 2) [level3]
  -- >>> level1 = patternWith (Just 3) [level2]
  -- >>> pattern = patternWith (Just 4) [level1]
  -- >>> sequenceA pattern
  -- Just (Pattern {value = 4, elements = [Pattern {value = 3, elements = [Pattern {value = 2, elements = [Pattern {value = 1, elements = []}]}]}]})
  --
  sequenceA = traverse id

-- | Create an atomic pattern (pattern with no elements) from a value.
--
-- This function provides a convenient way to create atomic patterns without
-- using verbose record syntax. The resulting pattern is functionally identical
-- to one created with @Pattern { value = x, elements = [] }@.
--
-- === Examples
--
-- Create an atomic pattern with a string value:
--
-- >>> atom = pattern "atom1"
-- >>> value atom
-- "atom1"
-- >>> elements atom
-- []
--
-- Create an atomic pattern with an integer value:
--
-- >>> num = pattern 42
-- >>> value num
-- 42
--
-- Create an atomic pattern with a custom type:
--
-- >>> data Person = Person { name :: String, age :: Maybe Int }
-- >>> person = pattern (Person "Alice" (Just 30))
-- >>> value person
-- Person {name = "Alice", age = Just 30}
--
-- === Functional Equivalence
--
-- The following are equivalent:
--
-- >>> pattern "test" == Pattern { value = "test", elements = [] }
-- True
pattern :: v -> Pattern v
pattern v = Pattern { value = v, elements = [] }

-- | Create a pattern with elements from a value and a list of pattern elements.
--
-- This function provides a convenient way to create patterns with elements
-- without using verbose record syntax. The resulting pattern is functionally
-- identical to one created with @Pattern { value = x, elements = ps }@.
--
-- The function preserves the order of elements in the input list and handles
-- all element counts: 0 (atomic pattern), 1 (singular pattern), 2 (pair),
-- or many (extended pattern).
--
-- === Examples
--
-- Create a singular pattern (one element):
--
-- >>> singular = patternWith "soccer" [pattern "a team sport involving kicking a ball"]
-- >>> length (elements singular)
-- 1
--
-- Create a pair pattern (two elements):
--
-- >>> pair = patternWith "knows" [pattern "Alice", pattern "Bob"]
-- >>> length (elements pair)
-- 2
--
-- Create an extended pattern (many elements):
--
-- >>> extended = patternWith "graph" [pattern "elem1", pattern "elem2", pattern "elem3"]
-- >>> length (elements extended)
-- 3
--
-- Empty list produces atomic pattern:
--
-- >>> atomic = patternWith "empty" []
-- >>> elements atomic
-- []
-- >>> atomic == pattern "empty"
-- True
--
-- === Functional Equivalence
--
-- The following are equivalent:
--
-- >>> patternWith "test" [pattern "elem"] == Pattern { value = "test", elements = [Pattern { value = "elem", elements = [] }] }
-- True
--
-- === Element Order
--
-- Element order is preserved:
--
-- >>> p1 = patternWith "seq" [pattern "a", pattern "b"]
-- >>> p2 = patternWith "seq" [pattern "b", pattern "a"]
-- >>> p1 == p2
-- False
patternWith :: v -> [Pattern v] -> Pattern v
patternWith v ps = Pattern { value = v, elements = ps }

-- | Create a pattern from a list of values by converting each value to an atomic pattern.
--
-- This function provides a convenient way to create patterns from lists of raw values.
-- Each value in the list is automatically converted to an atomic pattern, then all
-- atomic patterns are combined into a single pattern with the given decoration.
--
-- The function preserves the order of values in the input list and handles all
-- element counts: 0 (atomic pattern), 1 (singular pattern), 2 (pair), or many
-- (extended pattern).
--
-- === Examples
--
-- Create a pattern from a list of strings:
--
-- >>> p = fromList "graph" ["Alice", "Bob", "Charlie"]
-- >>> value p
-- "graph"
-- >>> length (elements p)
-- 3
-- >>> map value (elements p)
-- ["Alice","Bob","Charlie"]
--
-- Create a pattern from a list of integers:
--
-- >>> nums = fromList "numbers" [1, 2, 3, 4, 5]
-- >>> length (elements nums)
-- 5
--
-- Empty list produces atomic pattern:
--
-- >>> atomic = fromList "empty" []
-- >>> elements atomic
-- []
-- >>> atomic == pattern "empty"
-- True
--
-- === Functional Equivalence
--
-- The following are equivalent:
--
-- >>> fromList "test" ["a", "b"] == patternWith "test" [pattern "a", pattern "b"]
-- True
--
-- === Implementation
--
-- This function is implemented as:
--
-- @
-- fromList decoration values = patternWith decoration (map pattern values)
-- @
fromList :: v -> [v] -> Pattern v
fromList decoration values = patternWith decoration (map pattern values)

-- | Extract a pattern as a tuple preserving its structure.
--
-- Returns a tuple @(v, [Pattern v])@ where the first element is the pattern's
-- value and the second element is the list of element patterns. This function
-- preserves the pattern's structure by keeping elements as Pattern values
-- rather than flattening them.
--
-- The tuple representation directly reflects the Pattern's structure:
-- the value (decoration) and the list of pattern elements. This enables
-- structure-preserving operations and makes the pattern's composition explicit.
--
-- === Examples
--
-- Atomic pattern (no elements):
--
-- >>> atom = Pattern { value = "test", elements = [] }
-- >>> toTuple atom
-- ("test", [])
--
-- Pattern with multiple elements:
--
-- >>> elem1 = Pattern { value = "a", elements = [] }
-- >>> elem2 = Pattern { value = "b", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [elem1, elem2] }
-- >>> toTuple pattern
-- ("root", [Pattern {value = "a", elements = []},Pattern {value = "b", elements = []}])
--
-- Nested pattern structure:
--
-- >>> inner = Pattern { value = "inner", elements = [] }
-- >>> middle = Pattern { value = "middle", elements = [inner] }
-- >>> pattern = Pattern { value = "root", elements = [middle] }
-- >>> toTuple pattern
-- ("root", [Pattern {value = "middle", elements = [Pattern {value = "inner", elements = []}]}])
--
-- Pattern with integer values:
--
-- >>> elem1 = Pattern { value = 10, elements = [] }
-- >>> elem2 = Pattern { value = 20, elements = [] }
-- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
-- >>> toTuple pattern
-- (100, [Pattern {value = 10, elements = []},Pattern {value = 20, elements = []}])
--
-- === Structure Preservation
--
-- The @toTuple@ function preserves the pattern's structure:
--
-- * Elements remain as Pattern values (not flattened to their values)
-- * Nested structures are preserved in the elements list
-- * The pattern's value and elements are accessible separately
--
-- This is different from @toList@ which flattens all values into a single list.
-- Use @toTuple@ when you need to work with the pattern's value and elements
-- separately while maintaining the structural relationship.
--
-- === Edge Cases
--
-- **Atomic patterns** (no elements):
--
-- >>> atom = Pattern { value = "atom", elements = [] }
-- >>> toTuple atom
-- ("atom", [])
--
-- **Singular patterns** (one element):
--
-- >>> elem = Pattern { value = "elem", elements = [] }
-- >>> pattern = Pattern { value = "singular", elements = [elem] }
-- >>> toTuple pattern
-- ("singular", [Pattern {value = "elem", elements = []}])
--
-- **Patterns with many elements**:
--
-- >>> elems = [Pattern { value = "a", elements = [] }, Pattern { value = "b", elements = [] }, Pattern { value = "c", elements = [] }]
-- >>> pattern = Pattern { value = "root", elements = elems }
-- >>> toTuple pattern
-- ("root", [Pattern {value = "a", elements = []},Pattern {value = "b", elements = []},Pattern {value = "c", elements = []}])
--
toTuple :: Pattern v -> (v, [Pattern v])
toTuple (Pattern v els) = (v, els)

-- | Extract all values from a pattern as a flat list, explicitly flattening all nesting levels.
--
-- This function extracts all values from the pattern structure, including the pattern's own value
-- and all element values at all nesting levels, into a single flat list. The function is equivalent
-- to @toList@ (standard Foldable behavior) but is provided explicitly for clarity and to make
-- flattening operations intentional.
--
-- The @flatten@ function processes all values in the pattern structure:
--
-- * The pattern's own value is included in the result
-- * All element values are processed recursively
-- * Values from all nesting levels are included
-- * The result is always a flat list (no nested lists)
--
-- === Relationship to toList
--
-- The @flatten@ function is equivalent to @toList@ (standard Foldable behavior):
--
-- @
-- flatten p = toList p
-- @
--
-- Both functions extract all values as a flat list. Use @flatten@ when you want to make the
-- flattening operation explicit, or use @toList@ for standard Foldable behavior.
--
-- === Examples
--
-- Atomic pattern:
--
-- >>> atom = Pattern { value = "test", elements = [] }
-- >>> flatten atom
-- ["test"]
--
-- Pattern with multiple elements:
--
-- >>> elem1 = Pattern { value = "a", elements = [] }
-- >>> elem2 = Pattern { value = "b", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [elem1, elem2] }
-- >>> flatten pattern
-- ["root", "a", "b"]
--
-- Nested pattern structure:
--
-- >>> inner = Pattern { value = "inner", elements = [] }
-- >>> middle = Pattern { value = "middle", elements = [inner] }
-- >>> pattern = Pattern { value = "root", elements = [middle] }
-- >>> flatten pattern
-- ["root", "middle", "inner"]
--
-- Pattern with integer values:
--
-- >>> elem1 = Pattern { value = 10, elements = [] }
-- >>> elem2 = Pattern { value = 20, elements = [] }
-- >>> pattern = Pattern { value = 100, elements = [elem1, elem2] }
-- >>> flatten pattern
-- [100, 10, 20]
--
-- Using flatten for aggregation:
--
-- >>> pattern = Pattern { value = 10, elements = [Pattern { value = 5, elements = [] }, Pattern { value = 3, elements = [] }] }
-- >>> sum (flatten pattern)
-- 18
--
-- === Edge Cases
--
-- **Atomic patterns** (no elements):
--
-- >>> atom = Pattern { value = 42, elements = [] }
-- >>> flatten atom
-- [42]
--
-- **Patterns with empty elements list**:
--
-- >>> pattern = Pattern { value = 10, elements = [] }
-- >>> flatten pattern
-- [10]
--
-- **Singular patterns** (one element):
--
-- >>> elem = Pattern { value = 5, elements = [] }
-- >>> pattern = Pattern { value = 10, elements = [elem] }
-- >>> flatten pattern
-- [10, 5]
--
-- **Patterns with many elements**:
--
-- >>> elems = map (\i -> Pattern { value = i, elements = [] }) [1..5]
-- >>> pattern = Pattern { value = 100, elements = elems }
-- >>> flatten pattern
-- [100, 1, 2, 3, 4, 5]
--
-- **Deep nesting** (3+ levels):
--
-- >>> level4 = Pattern { value = 1, elements = [] }
-- >>> level3 = Pattern { value = 2, elements = [level4] }
-- >>> level2 = Pattern { value = 3, elements = [level3] }
-- >>> level1 = Pattern { value = 4, elements = [level2] }
-- >>> pattern = Pattern { value = 5, elements = [level1] }
-- >>> flatten pattern
-- [5, 4, 3, 2, 1]
--
flatten :: Pattern a -> [a]
flatten = toList

-- | Query the number of direct elements in a pattern's sequence.
--
-- Returns the count of direct child elements in the pattern's sequence.
-- This function provides the most basic structural information about a pattern,
-- indicating how many elements are directly contained in the pattern's sequence.
--
-- The @length@ function counts only direct children, not nested descendants.
-- For example, a pattern with one element that itself contains elements will
-- have @length@ of 1, not the total count of all nested elements.
--
-- === Relationship to elements
--
-- The @length@ function is equivalent to @length (elements p)@:
--
-- @
-- length p = length (elements p)
-- @
--
-- This provides a convenient way to query element count without explicitly
-- accessing the @elements@ field.
--
-- === Examples
--
-- Atomic pattern (no elements):
--
-- >>> atom = Pattern { value = "atom", elements = [] }
-- >>> length atom
-- 0
--
-- Singular pattern (one element):
--
-- >>> elem = Pattern { value = "elem", elements = [] }
-- >>> pattern = Pattern { value = "pattern", elements = [elem] }
-- >>> length pattern
-- 1
--
-- Pattern with multiple elements:
--
-- >>> elem1 = Pattern { value = "e1", elements = [] }
-- >>> elem2 = Pattern { value = "e2", elements = [] }
-- >>> elem3 = Pattern { value = "e3", elements = [] }
-- >>> pattern = Pattern { value = "pattern", elements = [elem1, elem2, elem3] }
-- >>> length pattern
-- 3
--
-- Nested pattern (counts only direct children):
--
-- >>> inner = Pattern { value = "inner", elements = [] }
-- >>> middle = Pattern { value = "middle", elements = [inner] }
-- >>> outer = Pattern { value = "outer", elements = [middle] }
-- >>> pattern = Pattern { value = "root", elements = [outer] }
-- >>> length pattern
-- 1
-- >>> length outer
-- 1
-- >>> length middle
-- 1
-- >>> length inner
-- 0
--
-- === Edge Cases
--
-- **Atomic patterns** (no elements):
--
-- >>> length (Pattern { value = "atom", elements = [] })
-- 0
--
-- **Patterns with empty elements list**:
--
-- >>> length (Pattern { value = "empty", elements = [] })
-- 0
--
-- **Patterns with many elements**:
--
-- >>> elems = map (\i -> Pattern { value = i, elements = [] }) [1..10]
-- >>> pattern = Pattern { value = 100, elements = elems }
-- >>> length pattern
-- 10
--
-- === Performance
--
-- The @length@ function completes in O(1) time for patterns with elements
-- stored as lists, as it simply returns the length of the elements list.
-- Performance is constant regardless of pattern structure or nesting depth.
--
-- === Type Safety
--
-- The @length@ function works with patterns of any value type @v@:
--
-- >>> length (Pattern { value = "test", elements = [] } :: Pattern String)
-- 0
-- >>> length (Pattern { value = 42, elements = [] } :: Pattern Int)
-- 0
--
length :: Pattern v -> Int
length (Pattern _ els) = P.length els

-- | Query the total number of nodes in a pattern structure.
--
-- Returns the total count of all nodes in the pattern structure, including
-- the pattern itself and all nested patterns at all levels. This provides a
-- complete picture of pattern complexity by counting every node in the
-- recursive structure.
--
-- The @size@ function counts all nodes recursively:
--
-- * The pattern itself counts as 1 node
-- * Each element pattern is counted recursively
-- * All nested patterns at all levels are included
--
-- This is different from @length@, which counts only direct children.
-- The @size@ function provides the total node count across the entire
-- pattern structure.
--
-- === Relationship to length
--
-- The @size@ function is always greater than or equal to @length@:
--
-- @
-- size p >= length p
-- @
--
-- This is because @size@ counts the root node plus all descendants, while
-- @length@ counts only direct children.
--
-- === Recursive Definition
--
-- The @size@ function is defined recursively:
--
-- @
-- size p = 1 + sum (map size (elements p))
-- @
--
-- This means:
-- * The pattern itself contributes 1 node
-- * Each element's size is computed recursively
-- * The sum of all element sizes is added to 1
--
-- === Examples
--
-- Atomic pattern (single node):
--
-- >>> atom = Pattern { value = "atom", elements = [] }
-- >>> size atom
-- 1
--
-- Pattern with direct elements (no nesting):
--
-- >>> elem1 = Pattern { value = "e1", elements = [] }
-- >>> elem2 = Pattern { value = "e2", elements = [] }
-- >>> elem3 = Pattern { value = "e3", elements = [] }
-- >>> pattern = Pattern { value = "pattern", elements = [elem1, elem2, elem3] }
-- >>> size pattern
-- 4
--
-- Deeply nested pattern:
--
-- >>> level4 = Pattern { value = "level4", elements = [] }
-- >>> level3 = Pattern { value = "level3", elements = [level4] }
-- >>> level2 = Pattern { value = "level2", elements = [level3] }
-- >>> level1 = Pattern { value = "level1", elements = [level2] }
-- >>> pattern = Pattern { value = "root", elements = [level1] }
-- >>> size pattern
-- 5
--
-- Pattern with varying branch depths:
--
-- >>> branch1Leaf = Pattern { value = "b1leaf", elements = [] }
-- >>> branch1 = Pattern { value = "b1", elements = [branch1Leaf] }
-- >>> branch2Mid = Pattern { value = "b2mid", elements = [] }
-- >>> branch2Leaf = Pattern { value = "b2leaf", elements = [] }
-- >>> branch2 = Pattern { value = "b2", elements = [branch2Mid, branch2Leaf] }
-- >>> branch3 = Pattern { value = "b3", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [branch1, branch2, branch3] }
-- >>> size pattern
-- 7
--
-- === Edge Cases
--
-- **Atomic patterns** (no elements):
--
-- >>> size (Pattern { value = "atom", elements = [] })
-- 1
--
-- **Patterns with empty elements list**:
--
-- >>> size (Pattern { value = "empty", elements = [] })
-- 1
--
-- **Patterns with many direct elements**:
--
-- >>> elems = map (\i -> Pattern { value = i, elements = [] }) [1..10]
-- >>> pattern = Pattern { value = 100, elements = elems }
-- >>> size pattern
-- 11
--
-- **Deep nesting** (many levels):
--
-- >>> level5 = Pattern { value = 1, elements = [] }
-- >>> level4 = Pattern { value = 2, elements = [level5] }
-- >>> level3 = Pattern { value = 3, elements = [level4] }
-- >>> level2 = Pattern { value = 4, elements = [level3] }
-- >>> level1 = Pattern { value = 5, elements = [level2] }
-- >>> pattern = Pattern { value = 6, elements = [level1] }
-- >>> size pattern
-- 6
--
-- === Performance
--
-- The @size@ function traverses the entire pattern structure recursively,
-- visiting every node exactly once. Time complexity is O(n) where n is the
-- total number of nodes in the pattern structure. For patterns with up to
-- 1000 nodes, the function should complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @size@ function works with patterns of any value type @v@:
--
-- >>> size (Pattern { value = "test", elements = [] } :: Pattern String)
-- 1
-- >>> size (Pattern { value = 42, elements = [] } :: Pattern Int)
-- 1
--
size :: Pattern v -> Int
size (Pattern _ els) = 1 + sum (map size els)

-- | Query the maximum nesting depth of a pattern structure.
--
-- Returns the maximum depth of any path from the root to a leaf node in the
-- pattern structure. This provides insight into pattern complexity and helps
-- validate depth constraints.
--
-- The @depth@ function measures the maximum nesting level:
--
-- * Atomic patterns (no elements) have depth 0 (root only, no nesting)
-- * Patterns with elements have depth 1 + the maximum depth of any element
-- * The depth is the maximum across all branches in the pattern structure
--
-- This is different from @size@, which counts total nodes, and @length@,
-- which counts only direct children. The @depth@ function provides the
-- maximum path length from root to any leaf.
--
-- === Depth Counting Convention
--
-- Depth follows standard tree depth conventions:
--
-- * Depth 0: Atomic pattern (root only, no nesting levels below root)
-- * Depth 1: One level of nesting (root -> element)
-- * Depth n: n levels of nesting (root -> ... -> leaf, n steps)
--
-- === Recursive Definition
--
-- The @depth@ function is defined recursively:
--
-- @
-- depth (Pattern _ []) = 0
-- depth (Pattern _ els) = 1 + maximum (map depth els)
-- @
--
-- This means:
-- * Atomic patterns (no elements) have depth 0
-- * Patterns with elements have depth 1 plus the maximum depth of any element
-- * The maximum is taken across all branches to find the deepest path
--
-- === Examples
--
-- Atomic pattern (no nesting):
--
-- >>> atom = Pattern { value = "atom", elements = [] }
-- >>> depth atom
-- 0
--
-- One level of nesting:
--
-- >>> elem = Pattern { value = "elem", elements = [] }
-- >>> pattern = Pattern { value = "pattern", elements = [elem] }
-- >>> depth pattern
-- 1
--
-- Multiple branches with different depths:
--
-- >>> branch1Leaf = Pattern { value = "b1leaf", elements = [] }
-- >>> branch1 = Pattern { value = "b1", elements = [branch1Leaf] }
-- >>> branch2Mid = Pattern { value = "b2mid", elements = [] }
-- >>> branch2Leaf = Pattern { value = "b2leaf", elements = [] }
-- >>> branch2Inner = Pattern { value = "b2inner", elements = [branch2Leaf] }
-- >>> branch2 = Pattern { value = "b2", elements = [branch2Mid, branch2Inner] }
-- >>> branch3 = Pattern { value = "b3", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [branch1, branch2, branch3] }
-- >>> depth pattern
-- 3
--
-- Deeply nested pattern:
--
-- >>> level4 = Pattern { value = "level4", elements = [] }
-- >>> level3 = Pattern { value = "level3", elements = [level4] }
-- >>> level2 = Pattern { value = "level2", elements = [level3] }
-- >>> level1 = Pattern { value = "level1", elements = [level2] }
-- >>> pattern = Pattern { value = "root", elements = [level1] }
-- >>> depth pattern
-- 4
--
-- === Edge Cases
--
-- **Atomic patterns** (no elements):
--
-- >>> depth (Pattern { value = "atom", elements = [] })
-- 0
--
-- **Patterns with empty elements list**:
--
-- >>> depth (Pattern { value = "empty", elements = [] })
-- 0
--
-- **Patterns with many direct elements** (all atomic):
--
-- >>> elems = map (\i -> Pattern { value = i, elements = [] }) [1..10]
-- >>> pattern = Pattern { value = 100, elements = elems }
-- >>> depth pattern
-- 1
--
-- **Deep nesting** (linear chain):
--
-- >>> level5 = Pattern { value = 1, elements = [] }
-- >>> level4 = Pattern { value = 2, elements = [level5] }
-- >>> level3 = Pattern { value = 3, elements = [level4] }
-- >>> level2 = Pattern { value = 4, elements = [level3] }
-- >>> level1 = Pattern { value = 5, elements = [level2] }
-- >>> pattern = Pattern { value = 6, elements = [level1] }
-- >>> depth pattern
-- 5
--
-- === Relationship to size
--
-- The @depth@ function is always less than or equal to @size - 1@:
--
-- @
-- depth p <= size p - 1
-- @
--
-- This is because the worst-case depth occurs in a linear chain where
-- depth = size - 1. In other structures, depth is typically less.
--
-- === Performance
--
-- The @depth@ function traverses the entire pattern structure recursively,
-- visiting every node to find the maximum depth. Time complexity is O(n)
-- where n is the total number of nodes. For patterns with up to 100 levels
-- of nesting, the function should complete in under 5 milliseconds.
--
-- === Type Safety
--
-- The @depth@ function works with patterns of any value type @v@:
--
-- >>> depth (Pattern { value = "test", elements = [] } :: Pattern String)
-- 0
-- >>> depth (Pattern { value = 42, elements = [] } :: Pattern Int)
-- 0
--
depth :: Pattern v -> Int
depth (Pattern _ els) = case els of
  [] -> 0
  _  -> 1 + maximum (map depth els)

-- | Extract all values from a pattern structure as a flat list.
--
-- Returns all values from the pattern structure, including the pattern's own
-- value and all element values at all nesting levels, as a single flat list.
-- This enables value aggregation, analysis, and transformation operations.
--
-- The @values@ function extracts all values in a specific order:
--
-- * The pattern's own value appears first in the result
-- * Element values are included recursively in order
-- * Values from all nesting levels are included
-- * The result is always a flat list (no nested lists)
--
-- This function is equivalent to @toList@ from the Foldable instance and
-- @flatten@ function. It provides an explicit, intentional way to extract
-- all values from a pattern structure.
--
-- === Relationship to toList and flatten
--
-- The @values@ function is equivalent to both @toList@ and @flatten@:
--
-- @
-- values p = toList p
-- values p = flatten p
-- @
--
-- All three functions extract all values as a flat list. Use @values@ when
-- you want to make value extraction explicit, or use @toList@ for standard
-- Foldable behavior, or @flatten@ for explicit flattening operations.
--
-- === Relationship to size
--
-- The number of values returned equals the total number of nodes:
--
-- @
-- length (values p) == size p
-- @
--
-- This is because each node in the pattern structure contributes exactly
-- one value to the result.
--
-- === Relationship to value
--
-- The first value in the result is always the pattern's own value:
--
-- @
-- head (values p) == value p
-- @
--
-- This ensures that the pattern's decoration value is always accessible
-- as the first element of the values list.
--
-- === Examples
--
-- Atomic pattern:
--
-- >>> atom = Pattern { value = "atom", elements = [] }
-- >>> values atom
-- ["atom"]
--
-- Pattern with multiple elements:
--
-- >>> elem1 = Pattern { value = "e1", elements = [] }
-- >>> elem2 = Pattern { value = "e2", elements = [] }
-- >>> elem3 = Pattern { value = "e3", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [elem1, elem2, elem3] }
-- >>> values pattern
-- ["root", "e1", "e2", "e3"]
--
-- Nested pattern structure:
--
-- >>> inner = Pattern { value = "inner", elements = [] }
-- >>> middle = Pattern { value = "middle", elements = [inner] }
-- >>> outer = Pattern { value = "outer", elements = [middle] }
-- >>> pattern = Pattern { value = "root", elements = [outer] }
-- >>> values pattern
-- ["root", "outer", "middle", "inner"]
--
-- Pattern with varying nesting depths:
--
-- >>> branch1Leaf = Pattern { value = "b1leaf", elements = [] }
-- >>> branch1 = Pattern { value = "b1", elements = [branch1Leaf] }
-- >>> branch2Mid = Pattern { value = "b2mid", elements = [] }
-- >>> branch2Leaf = Pattern { value = "b2leaf", elements = [] }
-- >>> branch2 = Pattern { value = "b2", elements = [branch2Mid, branch2Leaf] }
-- >>> branch3 = Pattern { value = "b3", elements = [] }
-- >>> pattern = Pattern { value = "root", elements = [branch1, branch2, branch3] }
-- >>> values pattern
-- ["root", "b1", "b1leaf", "b2", "b2mid", "b2leaf", "b3"]
--
-- Using values for aggregation:
--
-- >>> pattern = Pattern { value = 10, elements = [Pattern { value = 5, elements = [] }, Pattern { value = 3, elements = [] }] }
-- >>> sum (values pattern)
-- 18
--
-- === Edge Cases
--
-- **Atomic patterns** (no elements):
--
-- >>> values (Pattern { value = "atom", elements = [] })
-- ["atom"]
--
-- **Patterns with empty elements list**:
--
-- >>> values (Pattern { value = "empty", elements = [] })
-- ["empty"]
--
-- **Patterns with many direct elements**:
--
-- >>> elems = map (\i -> Pattern { value = i, elements = [] }) [1..5]
-- >>> pattern = Pattern { value = 100, elements = elems }
-- >>> values pattern
-- [100, 1, 2, 3, 4, 5]
--
-- **Deep nesting** (many levels):
--
-- >>> level4 = Pattern { value = 1, elements = [] }
-- >>> level3 = Pattern { value = 2, elements = [level4] }
-- >>> level2 = Pattern { value = 3, elements = [level3] }
-- >>> level1 = Pattern { value = 4, elements = [level2] }
-- >>> pattern = Pattern { value = 5, elements = [level1] }
-- >>> values pattern
-- [5, 4, 3, 2, 1]
--
-- === Performance
--
-- The @values@ function traverses the entire pattern structure recursively,
-- visiting every node exactly once. Time complexity is O(n) where n is the
-- total number of nodes. For patterns with up to 1000 nodes, the function
-- should complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @values@ function works with patterns of any value type @v@:
--
-- >>> values (Pattern { value = "test", elements = [] } :: Pattern String)
-- ["test"]
-- >>> values (Pattern { value = 42, elements = [] } :: Pattern Int)
-- [42]
--
values :: Pattern v -> [v]
values = toList

-- | Check if any value in a pattern satisfies a predicate.
--
-- Returns `True` if at least one value in the pattern (at any nesting level)
-- satisfies the predicate, `False` otherwise. The function considers all values
-- extracted from the pattern structure, including the pattern's own value and
-- all element values recursively.
--
-- The @anyValue@ function operates on flattened values extracted via
-- @Foldable.toList@, treating values independently of structural context.
-- This enables value-based queries like "does this pattern contain any negative
-- numbers?" without needing to know the exact structure or values.
--
-- === Relationship to Foldable
--
-- The @anyValue@ function leverages the @Foldable@ instance:
--
-- @
-- anyValue p = any p . toList
-- @
--
-- This ensures all values at all nesting levels are considered, consistent
-- with @Foldable@ semantics where values are extracted and processed
-- independently.
--
-- === Short-Circuit Behavior
--
-- The @anyValue@ function short-circuits on the first match, returning `True`
-- immediately when a matching value is found. This provides efficient behavior
-- for patterns where matching values appear early in the traversal.
--
-- === Examples
--
-- Atomic pattern:
--
-- >>> anyValue (> 0) (pattern 5)
-- True
-- >>> anyValue (> 10) (pattern 5)
-- False
--
-- Pattern with elements:
--
-- >>> pat = patternWith 0 [pattern 1, pattern 2]
-- >>> anyValue (> 0) pat
-- True
-- >>> anyValue (< 0) pat
-- False
--
-- Nested pattern:
--
-- >>> pat = patternWith 0 [patternWith 1 [pattern 2]]
-- >>> anyValue (> 1) pat
-- True
-- >>> anyValue (> 10) pat
-- False
--
-- === Performance
--
-- The @anyValue@ function completes in O(n) time where n is the total number
-- of nodes, but may short-circuit earlier if a match is found. For patterns
-- with up to 1000 nodes, the function should complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @anyValue@ function works with patterns of any value type @v@:
--
-- >>> anyValue (== "test") (pattern "test" :: Pattern String)
-- True
-- >>> anyValue (> 0) (pattern 42 :: Pattern Int)
-- True
--
anyValue :: (v -> Bool) -> Pattern v -> Bool
anyValue p = any p . toList

-- | Check if all values in a pattern satisfy a predicate.
--
-- Returns `True` only if every value in the pattern (at any nesting level)
-- satisfies the predicate, `False` otherwise. The function considers all values
-- extracted from the pattern structure, including the pattern's own value and
-- all element values recursively.
--
-- The @allValues@ function operates on flattened values extracted via
-- @Foldable.toList@, treating values independently of structural context.
-- This enables value-based queries like "are all values in this pattern valid?"
-- without needing to know the exact structure or values.
--
-- === Relationship to Foldable
--
-- The @allValues@ function leverages the @Foldable@ instance:
--
-- @
-- allValues p = all p . toList
-- @
--
-- This ensures all values at all nesting levels are considered, consistent
-- with @Foldable@ semantics where values are extracted and processed
-- independently.
--
-- === Vacuous Truth
--
-- For empty patterns (atomic patterns with no elements), the @allValues@
-- function evaluates the predicate on the pattern's value. This means:
--
-- * If the predicate matches the value: returns `True`
-- * If the predicate doesn't match the value: returns `False`
--
-- Note: This is different from standard vacuous truth semantics for empty
-- collections, as atomic patterns always have a value to evaluate.
--
-- === Examples
--
-- Atomic pattern:
--
-- >>> allValues (> 0) (pattern 5)
-- True
-- >>> allValues (> 10) (pattern 5)
-- False
--
-- Pattern where all values match:
--
-- >>> pat = patternWith 1 [pattern 2, pattern 3]
-- >>> allValues (> 0) pat
-- True
-- >>> allValues (> 1) pat
-- False
--
-- Pattern where some values don't match:
--
-- >>> pat = patternWith 1 [pattern 2, pattern 0]
-- >>> allValues (> 0) pat
-- False
--
-- Nested pattern:
--
-- >>> pat = patternWith 1 [patternWith 2 [pattern 3]]
-- >>> allValues (> 0) pat
-- True
-- >>> allValues (> 2) pat
-- False
--
-- === Performance
--
-- The @allValues@ function completes in O(n) time where n is the total number
-- of nodes, as it must check all values to verify the predicate holds for
-- every value. For patterns with up to 1000 nodes, the function should
-- complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @allValues@ function works with patterns of any value type @v@:
--
-- >>> allValues (== "test") (pattern "test" :: Pattern String)
-- True
-- >>> allValues (> 0) (pattern 42 :: Pattern Int)
-- True
--
allValues :: (v -> Bool) -> Pattern v -> Bool
allValues p = all p . toList

-- | Filter all subpatterns (including root) that match a pattern predicate.
--
-- Returns a list of all subpatterns in the pattern structure (including the
-- root pattern itself) that satisfy the predicate. The function recursively
-- traverses the entire pattern structure, examining each subpattern at all
-- nesting levels.
--
-- The @filterPatterns@ function operates on pattern structures, not just
-- flattened values. This enables structural queries like "find all patterns
-- with exactly 3 elements" or "find all patterns where elements form a
-- palindrome sequence" regardless of the internal content of individual
-- elements.
--
-- === Traversal Order
--
-- The function traverses patterns in a depth-first, pre-order fashion:
--
-- 1. The root pattern is checked first
-- 2. Then each element pattern is checked recursively
-- 3. Results are collected in traversal order
--
-- This ensures that the root pattern appears first in the result list,
-- followed by element patterns in their order of appearance.
--
-- === Relationship to findAllPatterns
--
-- The @filterPatterns@ and @findAllPatterns@ functions are equivalent:
--
-- @
-- filterPatterns p = findAllPatterns p
-- @
--
-- Both functions return all matching subpatterns. Use @filterPatterns@ for
-- consistency with standard filtering operations, or @findAllPatterns@ for
-- explicit "find all" semantics.
--
-- === Examples
--
-- Filter atomic patterns (patterns with no elements):
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b", patternWith "c" [pattern "d"]]
-- >>> filterPatterns (\p -> length (elements p) == 0) pat
-- [pattern "a", pattern "b", pattern "d"]
--
-- Filter patterns matching a value:
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b"]
-- >>> filterPatterns (\p -> value p == "root") pat
-- [Pattern {value = "root", elements = [Pattern {value = "a", elements = []},Pattern {value = "b", elements = []}]}]
--
-- Filter patterns with no matches:
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b"]
-- >>> filterPatterns (\p -> value p == "x") pat
-- []
--
-- Filter patterns matching element sequence structure:
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b", pattern "b", pattern "a"]
-- >>> length (filterPatterns (\p -> length (elements p) == 4 && 
-- ...                              value (elements p !! 0) == value (elements p !! 3) &&
-- ...                              value (elements p !! 1) == value (elements p !! 2)) pat)
-- 1
--
-- === Performance
--
-- The @filterPatterns@ function completes in O(n) time where n is the total
-- number of subpatterns (nodes) in the pattern structure. For patterns with up
-- to 1000 nodes, the function should complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @filterPatterns@ function works with patterns of any value type @v@:
--
-- >>> filterPatterns (\p -> value p == "test") (pattern "test" :: Pattern String)
-- [pattern "test"]
-- >>> filterPatterns (\p -> value p > 0) (pattern 42 :: Pattern Int)
-- [pattern 42]
--
filterPatterns :: (Pattern v -> Bool) -> Pattern v -> [Pattern v]
filterPatterns pred pat = 
  let matches = if pred pat then [pat] else []
      elementMatches = concatMap (filterPatterns pred) (elements pat)
  in matches ++ elementMatches

-- | Find the first subpattern (including root) that matches a pattern predicate.
--
-- Returns `Just` the first subpattern in the pattern structure (including the
-- root pattern itself) that satisfies the predicate, or `Nothing` if no
-- subpattern matches. The function recursively traverses the pattern structure
-- in depth-first, pre-order fashion, returning the first match found.
--
-- The @findPattern@ function operates on pattern structures, not just
-- flattened values. This enables structural queries like "find the first
-- pattern with exactly 3 elements" or "find the first pattern where elements
-- form a palindrome sequence" regardless of the internal content of individual
-- elements.
--
-- === Traversal Order
--
-- The function traverses patterns in a depth-first, pre-order fashion:
--
-- 1. The root pattern is checked first
-- 2. Then each element pattern is checked recursively
-- 3. The first match is returned immediately (short-circuit behavior)
--
-- This ensures that the root pattern is checked before any element patterns,
-- and matches are found in traversal order.
--
-- === Relationship to filterPatterns
--
-- The @findPattern@ function returns the first match from @filterPatterns@:
--
-- @
-- findPattern p pat = listToMaybe (filterPatterns p pat)
-- @
--
-- Use @findPattern@ when you only need the first match, or @filterPatterns@
-- when you need all matches.
--
-- === Examples
--
-- Find first atomic pattern:
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b"]
-- >>> findPattern (\p -> length (elements p) == 0) pat
-- Just (pattern "a")
--
-- Find root pattern:
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b"]
-- >>> findPattern (\p -> value p == "root") pat
-- Just (Pattern {value = "root", elements = [Pattern {value = "a", elements = []},Pattern {value = "b", elements = []}]})
--
-- Find pattern with no matches:
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b"]
-- >>> findPattern (\p -> value p == "x") pat
-- Nothing
--
-- === Performance
--
-- The @findPattern@ function completes in O(n) time where n is the total
-- number of subpatterns (nodes) in the pattern structure, but may short-circuit
-- earlier if a match is found. For patterns with up to 1000 nodes, the function
-- should complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @findPattern@ function works with patterns of any value type @v@:
--
-- >>> findPattern (\p -> value p == "test") (pattern "test" :: Pattern String)
-- Just (pattern "test")
-- >>> findPattern (\p -> value p > 0) (pattern 42 :: Pattern Int)
-- Just (pattern 42)
--
findPattern :: (Pattern v -> Bool) -> Pattern v -> Maybe (Pattern v)
findPattern pred pat
  | pred pat = Just pat
  | otherwise = foldr (\elemPat acc -> case acc of
      Just _ -> acc  -- Already found a match, keep it
      Nothing -> findPattern pred elemPat) Nothing (elements pat)

-- | Find all subpatterns (including root) that match a pattern predicate.
--
-- Returns a list of all subpatterns in the pattern structure (including the
-- root pattern itself) that satisfy the predicate. The function recursively
-- traverses the entire pattern structure, examining each subpattern at all
-- nesting levels.
--
-- The @findAllPatterns@ function is equivalent to @filterPatterns@:
--
-- @
-- findAllPatterns p = filterPatterns p
-- @
--
-- Both functions return all matching subpatterns. Use @filterPatterns@ for
-- consistency with standard filtering operations, or @findAllPatterns@ for
-- explicit "find all" semantics.
--
-- === Examples
--
-- Find all atomic patterns:
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b"]
-- >>> findAllPatterns (\p -> length (elements p) == 0) pat
-- [pattern "a", pattern "b"]
--
-- === Performance
--
-- The @findAllPatterns@ function completes in O(n) time where n is the total
-- number of subpatterns (nodes) in the pattern structure. For patterns with up
-- to 1000 nodes, the function should complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @findAllPatterns@ function works with patterns of any value type @v@:
--
-- >>> findAllPatterns (\p -> value p == "test") (pattern "test" :: Pattern String)
-- [pattern "test"]
-- >>> findAllPatterns (\p -> value p > 0) (pattern 42 :: Pattern Int)
-- [pattern 42]
--
findAllPatterns :: (Pattern v -> Bool) -> Pattern v -> [Pattern v]
findAllPatterns = filterPatterns

-- | Check if two patterns match structurally.
--
-- Returns `True` if the two patterns have the same structure (same values at
-- corresponding positions and same element structure), `False` otherwise.
-- The function performs recursive structural comparison, distinguishing patterns
-- based on their structure, not just flattened values.
--
-- The @matches@ function is equivalent to structural equality (`==`):
--
-- @
-- matches p1 p2 = p1 == p2
-- @
--
-- However, @matches@ provides explicit, intentional structural matching semantics,
-- making it clear that the comparison is based on pattern structure rather than
-- value-based equality.
--
-- === Structural Comparison
--
-- Two patterns match if and only if:
--
-- 1. Their values are equal (using `Eq` for the value type)
-- 2. Their element lists have the same length
-- 3. Corresponding elements match recursively
--
-- This ensures that patterns with the same flattened values but different
-- structures are distinguished. For example, a pattern with two direct
-- elements does not match a pattern with one element containing another element,
-- even if the flattened values are the same.
--
-- === Relationship to Eq
--
-- The @matches@ function is equivalent to the `Eq` instance:
--
-- @
-- matches p1 p2 = p1 == p2
-- @
--
-- Use @matches@ when you want explicit structural matching semantics, or use
-- `==` for standard equality checking.
--
-- === Examples
--
-- Identical patterns match:
--
-- >>> pat1 = patternWith "root" [pattern "a", pattern "b"]
-- >>> pat2 = patternWith "root" [pattern "a", pattern "b"]
-- >>> matches pat1 pat2
-- True
--
-- Patterns with different values don't match:
--
-- >>> pat1 = patternWith "root1" [pattern "a", pattern "b"]
-- >>> pat2 = patternWith "root2" [pattern "a", pattern "b"]
-- >>> matches pat1 pat2
-- False
--
-- Patterns with different element counts don't match:
--
-- >>> pat1 = patternWith "root" [pattern "a", pattern "b"]
-- >>> pat2 = patternWith "root" [pattern "a"]
-- >>> matches pat1 pat2
-- False
--
-- Patterns with same flattened values but different structures don't match:
--
-- >>> pat1 = patternWith "root" [pattern "a", pattern "b"]
-- >>> pat2 = patternWith "a" [patternWith "b" [pattern "root"]]
-- >>> matches pat1 pat2
-- False
--
-- Atomic patterns:
--
-- >>> matches (pattern "a") (pattern "a")
-- True
-- >>> matches (pattern "a") (pattern "b")
-- False
--
-- === Performance
--
-- The @matches@ function completes in O(n) time where n is the total number
-- of nodes in the smaller pattern. For patterns with up to 1000 nodes, the
-- function should complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @matches@ function requires that the value type @v@ has an `Eq` instance:
--
-- @
-- matches :: (Eq v) => Pattern v -> Pattern v -> Bool
-- @
--
-- This ensures that pattern values can be compared for equality, which is
-- necessary for structural matching.
--
matches :: (Eq v) => Pattern v -> Pattern v -> Bool
matches = (==)

-- | Check if a pattern contains a subpattern.
--
-- Returns `True` if the pattern contains the subpattern anywhere in its structure
-- (including the pattern itself), `False` otherwise. The function recursively
-- searches through all subpatterns in the pattern structure, checking for
-- structural equality with the target subpattern.
--
-- The @contains@ function checks for structural containment:
--
-- * A pattern always contains itself (reflexivity)
-- * A pattern contains all its direct elements
-- * A pattern contains all nested subpatterns recursively
--
-- This enables pattern analysis operations like "does this pattern contain a
-- specific subpattern?" or "is this pattern structure present in another pattern?"
--
-- === Relationship to filterPatterns
--
-- The @contains@ function can be implemented using @filterPatterns@:
--
-- @
-- contains p subpat = not (null (filterPatterns (== subpat) p))
-- @
--
-- However, @contains@ provides a more efficient implementation that short-circuits
-- on the first match, and provides explicit containment semantics.
--
-- === Relationship to matches
--
-- The @contains@ function uses @matches@ internally to check for structural
-- equality between the pattern and subpatterns. It checks if the pattern itself
-- matches the subpattern, or recursively checks if any element contains the subpattern:
--
-- @
-- contains p subpat = matches p subpat || any (\elemPat -> contains elemPat subpat) (elements p)
-- @
--
-- This ensures that containment is based on structural matching, not just
-- value-based equality.
--
-- === Examples
--
-- Pattern containing a subpattern:
--
-- >>> subpat = pattern "a"
-- >>> pat = patternWith "root" [subpat, pattern "b"]
-- >>> contains pat subpat
-- True
--
-- Pattern not containing a subpattern:
--
-- >>> subpat = pattern "x"
-- >>> pat = patternWith "root" [pattern "a", pattern "b"]
-- >>> contains pat subpat
-- False
--
-- Pattern containing itself (self-containment):
--
-- >>> pat = patternWith "root" [pattern "a", pattern "b"]
-- >>> contains pat pat
-- True
--
-- Atomic patterns:
--
-- >>> pat1 = pattern "a"
-- >>> pat2 = pattern "b"
-- >>> contains pat1 pat1
-- True
-- >>> contains pat1 pat2
-- False
--
-- === Performance
--
-- The @contains@ function completes in O(n) time where n is the total number
-- of subpatterns in the pattern structure, but may short-circuit earlier if
-- the subpattern is found. For patterns with up to 1000 nodes, the function
-- should complete in under 10 milliseconds.
--
-- === Type Safety
--
-- The @contains@ function requires that the value type @v@ has an `Eq` instance:
--
-- @
-- contains :: (Eq v) => Pattern v -> Pattern v -> Bool
-- @
--
-- This ensures that pattern values can be compared for equality, which is
-- necessary for structural matching during containment checking.
--
contains :: (Eq v) => Pattern v -> Pattern v -> Bool
contains p subpat = 
  matches p subpat || any (\elemPat -> contains elemPat subpat) (elements p)

-- | Comonad instance for Pattern.
--
-- The Comonad instance enables context-aware computations where functions have
-- access to the full structural context (parent, siblings, depth, path) around
-- each value, not just the value itself. This extends beyond Foldable (which
-- only provides values) to enable computations that consider structural context,
-- depth, position, and relationships between pattern elements.
--
-- == Categorical Interpretation
--
-- From a category theory perspective, `Pattern` is a comonad that provides a way
-- to perform context-aware computations. The Comonad instance provides:
--
-- * **Context Access**: Functions have access to the full pattern structure at each
--   position, not just the value
-- * **Structure Preservation**: The pattern structure (element count, nesting depth,
--   element order) is preserved during context-aware transformations
-- * **Recursive Context**: Context is created recursively at all positions in the
--   pattern structure
-- * **Dual to Monad**: Comonad is the dual of Monad - while Monad builds structure,
--   Comonad breaks it down to access context
--
-- == Relationship to Zippers
--
-- Comonads are closely related to zippers. A zipper is a data structure that
-- represents a data structure with a focus point and its context. The Comonad
-- instance for Pattern provides zipper-like capabilities:
--
-- * **Focus**: `extract` gets the value at the current focus (root)
-- * **Context**: `duplicate` creates contexts at every position (like having a zipper
--   at each position)
-- * **Navigation**: `extend` lets you compute based on full context (like zipper
--   navigation)
--
-- The Comonad instance enables zipper-like operations without requiring an explicit
-- `Zipper` type, providing context-aware computations that need the full structural
-- context at each position.
--
-- == Comonad Laws
--
-- The Comonad instance must satisfy three mathematical laws:
--
-- 1. **Extract-Extend Law**: `extract . extend f = f`
--    Extracting from an extended computation gives the original result.
--
-- 2. **Extend-Extract Law**: `extend extract = id`
--    Extending with extract is identity.
--
-- 3. **Extend Composition Law**: `extend f . extend g = extend (f . extend g)`
--    Extend is associative.
--
-- These laws are verified through property-based testing in the test suite.
--
instance Comonad Pattern where
  -- | Extract the decoration value from a pattern.
  --
  -- Returns the pattern's decoration value (root value), which is the value
  -- at the focus point in the comonadic context. This is the fundamental
  -- operation of the Comonad instance, providing access to the value at
  -- the current focus.
  --
  -- === Examples
  --
  -- >>> extract (pattern 5)
  -- 5
  --
  -- >>> extract (patternWith "test" [pattern "a", pattern "b"])
  -- "test"
  --
  -- >>> extract (patternWith "root" [patternWith "a" [pattern "x"]])
  -- "root"
  extract :: Pattern v -> v
  extract (Pattern v _) = v
  
  -- | Create a pattern where each position contains the full pattern structure focused at that position.
  --
  -- This operation creates a pattern of contexts, where each position contains
  -- the full pattern structure focused at that position. This enables context-aware
  -- computations by providing the full structural context at each position.
  --
  -- === Context Creation
  --
  -- The duplicate operation creates contexts recursively:
  --
  -- * Root position contains the full original pattern
  -- * Each element position contains the pattern structure focused at that element
  -- * Contexts are created recursively for all nested positions
  --
  -- === Examples
  --
  -- Atomic pattern:
  --
  -- >>> duplicate (pattern 5)
  -- Pattern {value = Pattern {value = 5, elements = []}, elements = []}
  --
  -- Pattern with elements:
  --
  -- >>> let p = patternWith "root" [pattern "a", pattern "b"]
  -- >>> duplicate p
  -- Pattern {
  --   value = Pattern {value = "root", elements = [pattern "a", pattern "b"]},
  --   elements = [
  --     Pattern {value = Pattern {value = "a", elements = []}, elements = []},
  --     Pattern {value = Pattern {value = "b", elements = []}, elements = []}
  --   ]
  -- }
  duplicate :: Pattern v -> Pattern (Pattern v)
  duplicate p@(Pattern _ els) = 
    Pattern p (map duplicate els)
  
  -- | Apply a context-aware function to each position in a pattern.
  --
  -- This operation applies a function that receives the full pattern structure
  -- at each position, not just the value. The function is applied recursively
  -- to all positions in the pattern structure, creating a new pattern where
  -- each position contains the result of applying the function to the pattern
  -- structure at that position.
  --
  -- === Context-Aware Computation
  --
  -- The extend operation enables context-aware computations where functions have
  -- access to the full structural context (parent, siblings, depth, indices) around
  -- each value, not just the value itself. This extends beyond Foldable (which
  -- only provides values) to enable computations based on structural context.
  --
  -- === Examples
  --
  -- Compute depth at each position:
  --
  -- >>> let depthFunc p = depth p
  -- >>> let p = patternWith "root" [pattern "a", pattern "b"]
  -- >>> extend depthFunc p
  -- Pattern {value = 0, elements = [Pattern {value = 1, elements = []}, Pattern {value = 1, elements = []}]}
  --
  -- Compute size at each position:
  --
  -- >>> let sizeFunc p = size p
  -- >>> let p = patternWith "root" [pattern "a", pattern "b"]
  -- >>> extend sizeFunc p
  -- Pattern {value = 3, elements = [Pattern {value = 1, elements = []}, Pattern {value = 1, elements = []}]}
  extend :: (Pattern v -> w) -> Pattern v -> Pattern w
  extend f = fmap f . duplicate

-- | Compute depth (nesting level) at each position in the pattern structure.
--
-- This helper function uses the Comonad instance to compute the depth of the
-- pattern structure at each position. The depth represents the maximum nesting
-- level from the current position to the deepest nested pattern.
--
-- === Examples
--
-- Atomic pattern:
--
-- >>> depthAt (pattern 5)
-- Pattern {value = 0, elements = []}
--
-- Pattern with elements:
--
-- >>> let p = patternWith "root" [pattern "a", pattern "b"]
-- >>> depthAt p
-- Pattern {value = 1, elements = [Pattern {value = 0, elements = []}, Pattern {value = 0, elements = []}]}
--
-- Nested pattern:
--
-- >>> let p = patternWith "root" [patternWith "a" [pattern "x"], pattern "b"]
-- >>> depthAt p
-- Pattern {value = 2, elements = [Pattern {value = 1, elements = [Pattern {value = 0, elements = []}]}, Pattern {value = 0, elements = []}]}
--
-- === Relationship to Comonad
--
-- This function demonstrates the power of the Comonad instance by providing
-- convenient access to context-aware computations. It is equivalent to:
--
-- @
-- depthAt = extend depth
-- @
--
-- The function uses `extend` to apply the `depth` function at each position,
-- giving each position access to its full structural context.
depthAt :: Pattern v -> Pattern Int
depthAt = extend depth

-- | Compute size (total nodes) of subtree at each position.
--
-- This helper function uses the Comonad instance to compute the size of the
-- pattern structure (total number of nodes) at each position. The size includes
-- the current node and all nodes in its subtree.
--
-- === Examples
--
-- Atomic pattern:
--
-- >>> sizeAt (pattern 5)
-- Pattern {value = 1, elements = []}
--
-- Pattern with elements:
--
-- >>> let p = patternWith "root" [pattern "a", pattern "b"]
-- >>> sizeAt p
-- Pattern {value = 3, elements = [Pattern {value = 1, elements = []}, Pattern {value = 1, elements = []}]}
--
-- Nested pattern:
--
-- >>> let p = patternWith "root" [patternWith "a" [pattern "x"], pattern "b"]
-- >>> sizeAt p
-- Pattern {value = 4, elements = [Pattern {value = 2, elements = [Pattern {value = 1, elements = []}]}, Pattern {value = 1, elements = []}]}
--
-- === Relationship to Comonad
--
-- This function demonstrates the power of the Comonad instance by providing
-- convenient access to context-aware computations. It is equivalent to:
--
-- @
-- sizeAt = extend size
-- @
--
-- The function uses `extend` to apply the `size` function at each position,
-- giving each position access to its full structural context.
sizeAt :: Pattern v -> Pattern Int
sizeAt = extend size

-- | Compute indices from root to current position.
--
-- This helper function finds the path (list of indices) from the root pattern
-- to the current pattern position. The root position has an empty list of indices,
-- and each element position has indices indicating its path from the root.
--
-- === Indices Representation
--
-- Indices are represented as a list of integers, where each integer represents
-- the index of an element at that level. For example:
--
-- * Root position: `[]` (empty list)
-- * First element: `[0]` (first element at root level)
-- * Second element: `[1]` (second element at root level)
-- * First element of first element: `[0, 0]` (first element of first element)
--
-- === Examples
--
-- Atomic pattern (root position):
--
-- >>> indicesFromRoot (pattern 5) (pattern 5)
-- []
--
-- Pattern with elements:
--
-- >>> let root = patternWith "root" [pattern "a", pattern "b"]
-- >>> indicesFromRoot root (pattern "a")
-- [0]
-- >>> indicesFromRoot root (pattern "b")
-- [1]
--
-- Nested pattern:
--
-- >>> let root = patternWith "root" [patternWith "a" [pattern "x"], pattern "b"]
-- >>> indicesFromRoot root (pattern "x")
-- [0, 0]
--
-- === Implementation Note
--
-- This function searches for the target pattern within the root pattern structure
-- by doing a structural comparison. It returns the first matching path found.
-- If the target pattern appears multiple times, it returns the path to the first
-- occurrence.
--
-- === Performance
--
-- The function completes in O(n) time where n is the total number of nodes in
-- the root pattern, as it must search through all positions to find the target.
indicesFromRoot :: (Eq v) => Pattern v -> Pattern v -> [Int]
indicesFromRoot root target
  | root == target = []
  | otherwise = findPath root target []

-- Helper function to find path from root to target
findPath :: (Eq v) => Pattern v -> Pattern v -> [Int] -> [Int]
findPath current target acc
  | current == target = reverse acc
  | otherwise = searchElements (elements current) target acc 0

-- Helper function to search through elements
searchElements :: (Eq v) => [Pattern v] -> Pattern v -> [Int] -> Int -> [Int]
searchElements [] _ _ _ = []  -- Not found
searchElements (elem:rest) target acc idx
  | found /= [] = found
  | otherwise = searchElements rest target acc (idx + 1)
  where
    found = findPath elem target (idx : acc)

-- | Compute indices from root to each position in the pattern structure.
--
-- This helper function uses the Comonad instance to compute the indices (list of
-- indices) from the root to each position. The root position has an empty list
-- of indices, and each element position has indices indicating its path from
-- the root.
--
-- === Examples
--
-- Atomic pattern:
--
-- >>> indicesAt (pattern 5)
-- Pattern {value = [], elements = []}
--
-- Pattern with elements:
--
-- >>> let p = patternWith "root" [pattern "a", pattern "b"]
-- >>> indicesAt p
-- Pattern {value = [], elements = [Pattern {value = [0], elements = []}, Pattern {value = [1], elements = []}]}
--
-- Nested pattern:
--
-- >>> let p = patternWith "root" [patternWith "a" [pattern "x"], pattern "b"]
-- >>> indicesAt p
-- Pattern {value = [], elements = [Pattern {value = [0], elements = [Pattern {value = [0, 0], elements = []}]}, Pattern {value = [1], elements = []}]}
--
-- === Relationship to Comonad
--
-- This function demonstrates the power of the Comonad instance by providing
-- convenient access to context-aware computations. It is equivalent to:
--
-- @
-- indicesAt p = extend (\pos -> indicesFromRoot p pos) p
-- @
--
-- The function uses `extend` to apply `indicesFromRoot` at each position,
-- giving each position access to its path from the root.
--
-- === Type Constraint
--
-- This function requires that the value type @v@ has an `Eq` instance, as
-- `indicesFromRoot` uses structural equality to find the target pattern.
indicesAt :: (Eq v) => Pattern v -> Pattern [Int]
indicesAt p = extend (\pos -> indicesFromRoot p pos) p
